<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TCP Tutorial: Part 2: Drawing sequence number charts</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="part2">Part 2: Drawing sequence number charts</a></h1><h2><a class="anchor" name="sec6a">
Recording data into output vectors</a></h2>
An established way of visualizing TCP behaviour is via drawing <em>sequence number charts</em>. The TCP module records sequence numbers and other info into OMNeT++ <em>output vectors</em>.<p>
OMNeT++ <em>output vectors</em> are basically time series data: every output vector contains an ordered sequence of <em>(time, value)</em> pairs, where <em>time</em> is the simulation time at which <em>value</em> was recorded. All output vectors from a single simulation run are written into an single output vector file, which is usually called <code>omnetpp.vec</code> (or <code><em>something</em>.vec</code>). Contents of the output vector file can be displayed with the Plove program which is part of OMNeT++, but its contents is textual so you can peek into it and process its contents with the tool of your liking (e.g. awk, perl, octave, matlab, gnuplot, xmgrace, R, spreadsheet programs, etc)<p>
Output vectors that record sequence numbers in sent and received TCP segments are the following:<ul>
<li><code>"send seq"</code>: sequence number in sent segment</li><li><code>"sent ack"</code>: ack number in sent segment</li><li><code>"rcvd seq"</code>: sequence number in received segment</li><li><code>"rcvd ack"</code>: ack number in received segment</li></ul>
<p>
Most simulators count in segments. OMNeT++ TCP, being more faithful to the RFC, counts in bytes.<p>
In addition, the following are recorded:<ul>
<li><code>"advertised window"</code>: the "window" values in received segments</li><li><code>"congestion window"</code>: commonly referred to as "cwnd"</li><li><code>"measured RTT"</code>: round-trip time measured (time between sending a segment and the arrival of its acknowledgement, only measured if there was no retransmission)</li><li><code>"smoothed RTT"</code>: the exponentially weighted average of measured round trip time values (according to Jacobson's algorithm)</li></ul>
<p>
Sometimes less is more, so you have control over which output vectors get actually recorded into the file, and you can limit the interval as well. For this you have to add a few lines to <code>omnetpp.ini</code>; see the section about configuring output vectors in the OMNeT++ manual.<h2><a class="anchor" name="sec6b">
An example: Round-Trip Time plot</a></h2>
Let us see an example. Run the <em>REDTest</em> simulation for a while, then stop and exit it. As a result, an <code>omnetpp.vec</code> file should appear in the directory. You can open that in Plove by typing<p>
<pre>
$ plove omnetpp.vec
</pre><p>
at the prompt. The Plove window will appear, and the list of output vector files will be displayed in the left panel. Suppose you want to see the round-trip times. We can plot output vectors from the right panel. You can copy there things by double-clicking vectors in the left panel, or by selecting one or more and using the arrow button in the middle.<p>
<div align="center">
<img src="plove-rtt.png" alt="plove-rtt.png">
</div>
<p>
Then create a plot using the toolbar button. After some zooming and customizing (right-clicking the chart will present you with a context menu for setting line styles, axis labels, etc) you might have something like the following:<p>
<div align="center">
<img src="plove-rttplot.png" alt="plove-rttplot.png">
</div>
<p>
You can save the plot in Postscript or in GIF, or copy it to the clipboard (Windows) for using it in reports and presentations.<h2><a class="anchor" name="sec6c">
Following TCP's operation on a sequence number plot</a></h2>
Let us see a sequence number plot from the same simulation:<p>
<div align="center">
<img src="plove-seqplot.png" alt="plove-seqplot.png">
</div>
<p>
This chart tells a whole story by itself. The horizontal axis is time, and the vertical is TCP sequence numbers. It shows that TCP in "s1" was sending data to "s2". In the beginning, the sequence numbers in sent segments (blue) are growing steadily. These segments also arrive at "s2" after some delay (see red dots by about .1s = 100ms to the right of the corresponding blue dots). These segments get acknowledged by "s2" (green triangles -- they are one MSS = 1024 bytes above the red dots, because red dots represent the first bytes of full-sized (1024 byte) segments that arrived, while the acknowledgements carry the next expected sequence number as ack.) These acknowledgements arrive at "s1" about 30ms later (yellow plus signs). The asymmetry in delays (100ms vs 30ms) is because acks are smaller, which results in smaller queueing delay at bottleneck links.<p>
Then a segment gets lost: one red dot at around t=44.81s is missing, meaning that that segment was not received by "s2" -- it was probably dropped in a router. The sender "s1" TCP doesn't know this, so it keeps transmitting until the window lasts. But "s2" keeps sending the same ack number (green triangles become horizontal), saying that it still wants the missing segment. When these acks arrive at "s1", at the 4th ack (3rd duplicate ack) it recognizes that something is wrong, and re-sends the missing segment (solitary blue dot). Finally, after 100ms this segment arrives at "s2" (solitary red dot), but until then "s2" sends further duplicate acks for all the segments that were still in the queue.<p>
When the missing segment arrives at "s2", ack numbers sent by "s2" jump up (solitary green triangle at about t=44.93s), signalling that the segment filled in the gap. (This also indicates that received segments above the gap were not discarded by "s2", but rather preserved for the future).<p>
When this ack arrives at "s1" (yellow cross under blue dot at t=44.95s), "s1" knows that all is well now, and spits out several segments at same time (blue dots in vertical line). This is because those duplicate acks inflated the congestion window (by indicating that above-sequence segments were received properly by "s2") -- this is the Fast Recovery algorithm. Of course these segments arrive at "s2" one after another (sequence of red dots starting at about t=44.98s is slanting), because they individually have to queue up for transmission. "s1" TCP gets permission to send further segments when further acks arrive (yellow crosses after t=45s).<p>
That's all.<h2><a class="anchor" name="sec6d">
Other hints for plotting</a></h2>
When plotting sequence numbers in Plove, useful filters are the "divide" filter (to translate from byte counts to segments), and "modulo" (to fold continually growing sequence numbers to the same interval, so that it can be displayed conveniently). To apply filters, right-click vectors in panel, and choose Pre-plot filtering... from the context menu. <hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 18:34:43 2006 for TCP Tutorial by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
