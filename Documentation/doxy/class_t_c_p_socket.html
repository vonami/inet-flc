<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>INET Framework for OMNeT++/OMNEST: TCPSocket Class Reference</title>
<link href="opp.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>TCPSocket Class Reference</h1><code>#include &lt;TCPSocket.h&gt;</code>
<p>
<a href="class_t_c_p_socket-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
TCPSocket is a convenience class, to make it easier to manage <a class="el" href="class_t_c_p.html">TCP</a> connections from your application models. You'd have one (or more) TCPSocket object(s) in your application simple module class, and call its member functions (<a class="el" href="class_t_c_p_socket.html#z129_1">bind()</a>, <a class="el" href="class_t_c_p_socket.html#z129_3">listen()</a>, <a class="el" href="class_t_c_p_socket.html#z129_5">connect()</a>, etc.) to open, close or abort a <a class="el" href="class_t_c_p.html">TCP</a> connection.<p>
TCPSocket chooses and remembers the connId for you, assembles and sends command packets (such as OPEN_ACTIVE, OPEN_PASSIVE, CLOSE, ABORT, etc.) to <a class="el" href="class_t_c_p.html">TCP</a>, and can also help you deal with packets and notification messages arriving from <a class="el" href="class_t_c_p.html">TCP</a>.<p>
A session which opens a connection from local port 1000 to 10.0.0.2:2000, sends 16K of data and closes the connection may be as simple as this (the code can be placed in your handleMessage() or activity()):<p>
<pre>
   TCPSocket socket;
   socket.connect(<a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>("10.0.0.2"), 2000);</pre><p>
<pre>   msg = new cMessage("data1");
   msg-&gt;setByteLength(16*1024);  // 16K
   socket.send(msg);</pre><p>
<pre>   socket.close();
 </pre><p>
Dealing with packets and notification messages coming from <a class="el" href="class_t_c_p.html">TCP</a> is somewhat more cumbersome. Basically you have two choices: you either process those messages yourself, or let TCPSocket do part of the job. For the latter, you give TCPSocket a callback object on which it'll invoke the appropriate member functions: socketEstablished(), socketDataArrived(), socketFailure(), socketPeerClosed(), etc (these are methods of <a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">TCPSocket::CallbackInterface</a>)., The callback object can be your simple module class too.<p>
This code skeleton example shows how to set up a TCPSocket to use the module itself as callback object:<p>
<pre>
 class MyModule : public cSimpleModule, public <a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">TCPSocket::CallbackInterface</a>
 {
     TCPSocket socket;
     virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent);
     virtual void socketFailure(int connId, void *yourPtr, int code);
     ...
 };</pre><p>
<pre> void MyModule::initialize() {
     socket.setCallbackObject(this,NULL);
 }</pre><p>
<pre> void MyModule::handleMessage(cMessage *msg) {
     if (socket.belongsToSocket(msg))
         socket.processMessage(msg); // dispatch to socketXXXX() methods
     else
         ...
 }</pre><p>
<pre> void MyModule::socketDataArrived(int, void *, cMessage *msg, bool) {
     ev &lt;&lt; "Received TCP data, " &lt;&lt; msg-&gt;byteLength() &lt;&lt; " bytes\\n";
     delete msg;
 }</pre><p>
<pre> void MyModule::socketFailure(int, void *, int code) {
     if (code==TCP_I_CONNECTION_RESET)
         ev &lt;&lt; "Connection reset!\\n";
     else if (code==TCP_I_CONNECTION_REFUSED)
         ev &lt;&lt; "Connection refused!\\n";
     else if (code==TCP_I_TIMEOUT)
         ev &lt;&lt; "Connection timed out!\\n";
 }
 </pre><p>
If you need to manage a large number of sockets (e.g. in a server application which handles multiple incoming connections), the <a class="el" href="class_t_c_p_socket_map.html">TCPSocketMap</a> class may be useful. The following code fragment to handle incoming connections is from the <a class="el" href="class_l_d_p.html">LDP</a> module:<p>
<pre>
 TCPSocket *socket = socketMap.findSocketFor(msg);
 if (!socket)
 {
     // not yet in socketMap, must be new incoming connection: add to socketMap
     socket = new TCPSocket(msg);
     socket-&gt;setOutputGate(gate("tcpOut"));
     socket-&gt;setCallbackObject(this, NULL);
     socketMap.addSocket(socket);
 }
 // dispatch to socketEstablished(), socketDataArrived(), socketPeerClosed()
 // or socketFailure()
 socket-&gt;processMessage(msg);
 </pre><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="class_t_c_p_socket_map.html">TCPSocketMap</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Handling of messages arriving from TCP</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z131_0">belongsToSocket</a> (cMessage *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z131_1">setCallbackObject</a> (<a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a> *<a class="el" href="class_t_c_p_socket.html#p6">cb</a>, void *<a class="el" href="class_t_c_p_socket.html#p7">yourPtr</a>=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z131_2">processMessage</a> (cMessage *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z131_3">belongsToAnyTCPSocket</a> (cMessage *msg)</td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#w9">State</a> { <br>
&nbsp;&nbsp;<a class="el" href="class_t_c_p_socket.html#w9w0">NOT_BOUND</a>, 
<a class="el" href="class_t_c_p_socket.html#w9w1">BOUND</a>, 
<a class="el" href="class_t_c_p_socket.html#w9w2">LISTENING</a>, 
<a class="el" href="class_t_c_p_socket.html#w9w3">CONNECTING</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_t_c_p_socket.html#w9w4">CONNECTED</a>, 
<a class="el" href="class_t_c_p_socket.html#w9w5">PEER_CLOSED</a>, 
<a class="el" href="class_t_c_p_socket.html#w9w6">LOCALLY_CLOSED</a>, 
<a class="el" href="class_t_c_p_socket.html#w9w7">CLOSED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_t_c_p_socket.html#w9w8">SOCKERROR</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#a0">TCPSocket</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#a1">TCPSocket</a> (cMessage *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#a2">~TCPSocket</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#a3">connectionId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#a4">state</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Getter functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z127_0">localAddress</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z127_1">localPort</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z127_2">remoteAddress</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z127_3">remotePort</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Opening and closing connections, sending data</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_0">setOutputGate</a> (cGate *toTcp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_1">bind</a> (int localPort)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_2">bind</a> (<a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> <a class="el" href="class_t_c_p_socket.html#p2">localAddr</a>, int localPort)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_3">listen</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_4">listenOnce</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_5">connect</a> (<a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> <a class="el" href="class_t_c_p_socket.html#p4">remoteAddr</a>, int remotePort)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_6">send</a> (cMessage *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_7">close</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_8">abort</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_9">requestStatus</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#z129_10">renewSocket</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#e0">stateName</a> (int state)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#b0">sendToTCP</a> (cMessage *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#b1">listen</a> (bool fork)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p0">connId</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p1">sockstate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p2">localAddr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p3">localPrt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p4">remoteAddr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p5">remotePrt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p6">cb</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p7">yourPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">cGate *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket.html#p8">gateToTcp</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a></td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w9" doxytag="TCPSocket::State"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="class_t_c_p_socket.html#w9">TCPSocket::State</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="w9w0" doxytag="NOT_BOUND"></a>NOT_BOUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w1" doxytag="BOUND"></a>BOUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w2" doxytag="LISTENING"></a>LISTENING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w3" doxytag="CONNECTING"></a>CONNECTING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w4" doxytag="CONNECTED"></a>CONNECTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w5" doxytag="PEER_CLOSED"></a>PEER_CLOSED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w6" doxytag="LOCALLY_CLOSED"></a>LOCALLY_CLOSED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w7" doxytag="CLOSED"></a>CLOSED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w8" doxytag="SOCKERROR"></a>SOCKERROR</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
<div class="fragment"><pre class="fragment">00147 {<a class="code" href="class_t_c_p_socket.html#w9w0">NOT_BOUND</a>, <a class="code" href="class_t_c_p_socket.html#w9w1">BOUND</a>, <a class="code" href="class_t_c_p_socket.html#w9w2">LISTENING</a>, <a class="code" href="class_t_c_p_socket.html#w9w3">CONNECTING</a>, <a class="code" href="class_t_c_p_socket.html#w9w4">CONNECTED</a>, <a class="code" href="class_t_c_p_socket.html#w9w5">PEER_CLOSED</a>, <a class="code" href="class_t_c_p_socket.html#w9w6">LOCALLY_CLOSED</a>, <a class="code" href="class_t_c_p_socket.html#w9w7">CLOSED</a>, <a class="code" href="class_t_c_p_socket.html#w9w8">SOCKERROR</a>};
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="TCPSocket::TCPSocket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TCPSocket::TCPSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. The <a class="el" href="class_t_c_p_socket.html#a3">connectionId()</a> method returns a valid Id right after constructor call. <div class="fragment"><pre class="fragment">00023 {
00024     <span class="comment">// don't allow user-specified connIds because they may conflict with</span>
00025     <span class="comment">// automatically assigned ones.</span>
00026     <a class="code" href="class_t_c_p_socket.html#p0">connId</a> = ev.getUniqueNumber();
00027     <a class="code" href="class_t_c_p_socket.html#p1">sockstate</a> = <a class="code" href="class_t_c_p_socket.html#w9w0">NOT_BOUND</a>;
00028 
00029     <a class="code" href="class_t_c_p_socket.html#p3">localPrt</a> = <a class="code" href="class_t_c_p_socket.html#p5">remotePrt</a> = -1;
00030     <a class="code" href="class_t_c_p_socket.html#p6">cb</a> = NULL;
00031     <a class="code" href="class_t_c_p_socket.html#p7">yourPtr</a> = NULL;
00032 
00033     <a class="code" href="class_t_c_p_socket.html#p8">gateToTcp</a> = NULL;
00034 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="TCPSocket::TCPSocket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TCPSocket::TCPSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor, to be used with forked sockets (see <a class="el" href="class_t_c_p_socket.html#z129_3">listen()</a>). The new connId will be picked up from the message: it should have arrived from <a class="el" href="class_t_c_p.html">TCP</a> and contain TCPCommmand control info. <div class="fragment"><pre class="fragment">00037 {
00038     <a class="code" href="class_t_c_p_command.html">TCPCommand</a> *ind = dynamic_cast&lt;TCPCommand *&gt;(msg-&gt;controlInfo());
00039     <span class="keywordflow">if</span> (!ind)
00040         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>(cMessage *): no <a class="code" href="class_t_c_p_command.html">TCPCommand</a> control info in message (not from <a class="code" href="class_t_c_p.html">TCP</a>?)");
00041 
00042     connId = ind-&gt;connId();
00043     sockstate = CONNECTED;
00044 
00045     localPrt = remotePrt = -1;
00046     cb = NULL;
00047     yourPtr = NULL;
00048 
00049     gateToTcp = NULL;
00050 
00051     if (msg-&gt;kind()==TCP_I_ESTABLISHED)
00052     {
00053         <span class="comment">// management of stockstate is left to processMessage() so we always</span>
00054         <span class="comment">// set it to CONNECTED in the ctor, whatever TCP_I_xxx arrives.</span>
00055         <span class="comment">// However, for convenience we extract TCPConnectInfo already here, so that</span>
00056         <span class="comment">// remote address/port can be read already after the ctor call.</span>
00057 
00058         <a class="code" href="class_t_c_p_connect_info.html">TCPConnectInfo</a> *connectInfo = dynamic_cast&lt;TCPConnectInfo *&gt;(msg-&gt;controlInfo());
00059         <a class="code" href="class_t_c_p_socket.html#p2">localAddr</a> = connectInfo-&gt;<a class="code" href="class_t_c_p_connect_info.html#a6">localAddr</a>();
00060         <a class="code" href="class_t_c_p_socket.html#p4">remoteAddr</a> = connectInfo-&gt;<a class="code" href="class_t_c_p_connect_info.html#a9">remoteAddr</a>();
00061         <a class="code" href="class_t_c_p_socket.html#p3">localPrt</a> = connectInfo-&gt;<a class="code" href="class_t_c_p_connect_info.html#a12">localPort</a>();
00062         remotePrt = connectInfo-&gt;<a class="code" href="class_t_c_p_connect_info.html#a14">remotePort</a>();
00063     }
00064 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="TCPSocket::~TCPSocket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TCPSocket::~<a class="el" href="class_t_c_p_socket.html">TCPSocket</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor <div class="fragment"><pre class="fragment">00186 {}
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z129_8" doxytag="TCPSocket::abort"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::abort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Aborts the connection. <div class="fragment"><pre class="fragment">00187 {
00188     <span class="keywordflow">if</span> (sockstate!=NOT_BOUND &amp;&amp; sockstate!=BOUND &amp;&amp; sockstate!=CLOSED &amp;&amp; sockstate!=SOCKERROR)
00189     {
00190         cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">"ABORT"</span>, TCP_C_ABORT);
00191         <a class="code" href="class_t_c_p_command.html">TCPCommand</a> *cmd = <span class="keyword">new</span> <a class="code" href="class_t_c_p_command.html">TCPCommand</a>();
00192         cmd-&gt;<a class="code" href="class_t_c_p_command.html#a7">setConnId</a>(connId);
00193         msg-&gt;setControlInfo(cmd);
00194         <a class="code" href="class_t_c_p_socket.html#b0">sendToTCP</a>(msg);
00195     }
00196     <a class="code" href="class_t_c_p_socket.html#p1">sockstate</a> = <a class="code" href="class_t_c_p_socket.html#w9w7">CLOSED</a>;
00197 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z131_3" doxytag="TCPSocket::belongsToAnyTCPSocket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool TCPSocket::belongsToAnyTCPSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if the message belongs to any TCPSocket instance. (This basically checks if the message has a <a class="el" href="class_t_c_p_command.html">TCPCommand</a> attached to it as controlInfo().) <div class="fragment"><pre class="fragment">00224 {
00225     <span class="keywordflow">return</span> dynamic_cast&lt;TCPCommand *&gt;(msg-&gt;controlInfo());
00226 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z131_0" doxytag="TCPSocket::belongsToSocket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool TCPSocket::belongsToSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if the message belongs to this socket instance (message has a <a class="el" href="class_t_c_p_command.html">TCPCommand</a> as controlInfo(), and the connId in it matches that of the socket.) <div class="fragment"><pre class="fragment">00218 {
00219     <span class="keywordflow">return</span> dynamic_cast&lt;TCPCommand *&gt;(msg-&gt;controlInfo()) &amp;&amp;
00220            ((<a class="code" href="class_t_c_p_command.html">TCPCommand</a> *)(msg-&gt;controlInfo()))-&gt;connId()==<a class="code" href="class_t_c_p_socket.html#p0">connId</a>;
00221 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_2" doxytag="TCPSocket::bind"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::bind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>localAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>localPort</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind the socket to a local port number and <a class="el" href="class_i_p.html">IP</a> address (useful with multi-homing). <div class="fragment"><pre class="fragment">00106 {
00107     <span class="keywordflow">if</span> (sockstate!=NOT_BOUND)
00108         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::bind(): socket already bound");
00109     <span class="comment">// allow -1 here, to make it possible to specify address only</span>
00110     if ((lPort&lt;0 || lPort&gt;65535) &amp;&amp; lPort!=-1)
00111         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::bind(): invalid port number %d", lPort);
00112 
00113     localAddr = lAddr;
00114     localPrt = lPort;
00115     sockstate = BOUND;
00116 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_1" doxytag="TCPSocket::bind"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::bind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>localPort</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind the socket to a local port number. <div class="fragment"><pre class="fragment">00095 {
00096     <span class="keywordflow">if</span> (sockstate!=NOT_BOUND)
00097         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::bind(): socket already bound");
00098     if (lPort&lt;0 || lPort&gt;65535)
00099         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::bind(): invalid port number %d", lPort);
00100 
00101     localPrt = lPort;
00102     sockstate = BOUND;
00103 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_7" doxytag="TCPSocket::close"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes the local end of the connection. With <a class="el" href="class_t_c_p.html">TCP</a>, a CLOSE operation means "I have no more data to send", and thus results in a one-way connection until the remote <a class="el" href="class_t_c_p.html">TCP</a> closes too (or the FIN_WAIT_1 timeout expires) <div class="fragment"><pre class="fragment">00174 {
00175     <span class="keywordflow">if</span> (sockstate!=CONNECTED &amp;&amp; sockstate!=PEER_CLOSED &amp;&amp; sockstate!=CONNECTING &amp;&amp; sockstate!=LISTENING)
00176         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::close(): not connected or close() already called");
00177 
00178     cMessage *msg = new cMessage("CLOSE", TCP_C_CLOSE);
00179     <a class="code" href="class_t_c_p_command.html">TCPCommand</a> *cmd = new <a class="code" href="class_t_c_p_command.html">TCPCommand</a>();
00180     cmd-&gt;setConnId(connId);
00181     msg-&gt;setControlInfo(cmd);
00182     sendToTCP(msg);
00183     sockstate = sockstate==CONNECTED ? LOCALLY_CLOSED : CLOSED;
00184 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_5" doxytag="TCPSocket::connect"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::connect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>remoteAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>remotePort</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Active OPEN to the given remote socket. <div class="fragment"><pre class="fragment">00138 {
00139     <span class="keywordflow">if</span> (sockstate!=NOT_BOUND &amp;&amp; sockstate!=BOUND)
00140         opp_error( "<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::connect(): connect() or listen() already called (need renewSocket()?)");
00141     if (remotePort&lt;0 || remotePort&gt;65535)
00142         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::connect(): invalid remote port number %d", remotePort);
00143 
00144     cMessage *msg = new cMessage("ActiveOPEN", TCP_C_OPEN_ACTIVE);
00145 
00146     remoteAddr = remoteAddress;
00147     remotePrt = remotePort;
00148 
00149     <a class="code" href="class_t_c_p_open_command.html">TCPOpenCommand</a> *openCmd = new <a class="code" href="class_t_c_p_open_command.html">TCPOpenCommand</a>();
00150     openCmd-&gt;setConnId(connId);
00151     openCmd-&gt;setLocalAddr(localAddr);
00152     openCmd-&gt;setLocalPort(localPrt);
00153     openCmd-&gt;setRemoteAddr(remoteAddr);
00154     openCmd-&gt;setRemotePort(remotePrt);
00155 
00156     msg-&gt;setControlInfo(openCmd);
00157     sendToTCP(msg);
00158     sockstate = CONNECTING;
00159 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="TCPSocket::connectionId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPSocket::connectionId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the internal connection Id. <a class="el" href="class_t_c_p.html">TCP</a> uses the (gate index, connId) pair to identify the connection when it receives a command from the application (or TCPSocket). <div class="fragment"><pre class="fragment">00193 {<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_socket.html#p0">connId</a>;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_3" doxytag="TCPSocket::listen"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::listen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initiates passive OPEN, creating a "forking" connection that will listen on the port you bound the socket to. Every incoming connection will get a new connId (and thus, must be handled with a new TCPSocket object), while the original connection (original connId) will keep listening on the port. The new TCPSocket object must be created with the TCPSocket(cMessage *msg) constructor.<p>
If you need to handle multiple incoming connections, the <a class="el" href="class_t_c_p_socket_map.html">TCPSocketMap</a> class can also be useful, and <a class="el" href="class_t_c_p_srv_host_app.html">TCPSrvHostApp</a> shows how to put it all together. See also <a class="el" href="class_t_c_p_open_command.html">TCPOpenCommand</a> documentation (neddoc) for more info. <div class="fragment"><pre class="fragment">00254 {<a class="code" href="class_t_c_p_socket.html#z129_3">listen</a>(<span class="keyword">true</span>);}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="TCPSocket::listen"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::listen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fork</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00119 {
00120     <span class="keywordflow">if</span> (sockstate!=BOUND)
00121         opp_error(sockstate==NOT_BOUND ? "<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>: must call bind() before listen()"
00122                                        : "<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::listen(): connect() or listen() already called");
00123 
00124     cMessage *msg = new cMessage("PassiveOPEN", TCP_C_OPEN_PASSIVE);
00125 
00126     <a class="code" href="class_t_c_p_open_command.html">TCPOpenCommand</a> *openCmd = new <a class="code" href="class_t_c_p_open_command.html">TCPOpenCommand</a>();
00127     openCmd-&gt;setLocalAddr(localAddr);
00128     openCmd-&gt;setLocalPort(localPrt);
00129     openCmd-&gt;setConnId(connId);
00130     openCmd-&gt;setFork(fork);
00131 
00132     msg-&gt;setControlInfo(openCmd);
00133     sendToTCP(msg);
00134     sockstate = LISTENING;
00135 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_4" doxytag="TCPSocket::listenOnce"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::listenOnce           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initiates passive OPEN to create a non-forking listening connection. Non-forking means that <a class="el" href="class_t_c_p.html">TCP</a> will accept the first incoming connection, and refuse subsequent ones.<p>
See <a class="el" href="class_t_c_p_open_command.html">TCPOpenCommand</a> documentation (neddoc) for more info. <div class="fragment"><pre class="fragment">00263 {<a class="code" href="class_t_c_p_socket.html#z129_3">listen</a>(<span class="keyword">false</span>);}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z127_0" doxytag="TCPSocket::localAddress"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> TCPSocket::localAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00209 {<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_socket.html#p2">localAddr</a>;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z127_1" doxytag="TCPSocket::localPort"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPSocket::localPort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00210 {<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_socket.html#p3">localPrt</a>;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z131_2" doxytag="TCPSocket::processMessage"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::processMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Examines the message (which should have arrived from <a class="el" href="class_t_c_p.html">TCP</a>), updates socket state, and if there is a callback object installed (see <a class="el" href="class_t_c_p_socket.html#z131_1">setCallbackObject()</a>, class <a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a>), dispatches to the appropriate method of it with the same yourPtr that you gave in the <a class="el" href="class_t_c_p_socket.html#z131_1">setCallbackObject()</a> call.<p>
The method deletes the message, unless (1) there is a callback object installed AND (2) the message is payload (message kind TCP_I_DATA or TCP_I_URGENT_DATA) when the responsibility of destruction is on the socketDataArrived() callback method.<p>
IMPORTANT: for performance reasons, this method doesn't check that the message belongs to this socket, i.e. belongsToSocket(msg) would return true! <div class="fragment"><pre class="fragment">00235 {
00236     ASSERT(<a class="code" href="class_t_c_p_socket.html#z131_0">belongsToSocket</a>(msg));
00237 
00238     <a class="code" href="class_t_c_p_status_info.html">TCPStatusInfo</a> *status;
00239     <a class="code" href="class_t_c_p_connect_info.html">TCPConnectInfo</a> *connectInfo;
00240     <span class="keywordflow">switch</span> (msg-&gt;kind())
00241     {
00242         <span class="keywordflow">case</span> <a class="code" href="_t_c_p_command__m_8h.html#a29a7">TCP_I_DATA</a>:
00243              <span class="keywordflow">if</span> (cb)
00244                  cb-&gt;socketDataArrived(connId, yourPtr, msg, false);
00245              else
00246                  delete msg;
00247              break;
00248         case TCP_I_URGENT_DATA:
00249              if (cb)
00250                  cb-&gt;socketDataArrived(connId, yourPtr, msg, true);
00251              else
00252                  delete msg;
00253              break;
00254         case TCP_I_ESTABLISHED:
00255              <span class="comment">// Note: this code is only for sockets doing active open, and nonforking</span>
00256              <span class="comment">// listening sockets. For a forking listening sockets, TCP_I_ESTABLISHED</span>
00257              <span class="comment">// carries a new connId which won't match the connId of this TCPSocket,</span>
00258              <span class="comment">// so you won't get here. Rather, when you see TCP_I_ESTABLISHED, you'll</span>
00259              <span class="comment">// want to create a new TCPSocket object via new TCPSocket(msg).</span>
00260              sockstate = CONNECTED;
00261              connectInfo = dynamic_cast&lt;<a class="code" href="class_t_c_p_connect_info.html">TCPConnectInfo</a> *&gt;(msg-&gt;controlInfo());
00262              localAddr = connectInfo-&gt;localAddr();
00263              remoteAddr = connectInfo-&gt;remoteAddr();
00264              localPrt = connectInfo-&gt;localPort();
00265              remotePrt = connectInfo-&gt;remotePort();
00266              delete msg;
00267              if (cb)
00268                  cb-&gt;socketEstablished(connId, yourPtr);
00269              break;
00270         case TCP_I_PEER_CLOSED:
00271              sockstate = sockstate==CONNECTED ? PEER_CLOSED : CLOSED;
00272              delete msg;
00273              if (cb)
00274                  cb-&gt;socketPeerClosed(connId, yourPtr);
00275              break;
00276         case TCP_I_CLOSED:
00277              sockstate = CLOSED;
00278              delete msg;
00279              if (cb)
00280                  cb-&gt;socketClosed(connId, yourPtr);
00281              break;
00282         case TCP_I_CONNECTION_REFUSED:
00283         case TCP_I_CONNECTION_RESET:
00284         case TCP_I_TIMED_OUT:
00285              sockstate = SOCKERROR;
00286              if (cb)
00287                  cb-&gt;socketFailure(connId, yourPtr, msg-&gt;kind());
00288              delete msg;
00289              break;
00290         case TCP_I_STATUS:
00291              status = check_and_cast&lt;<a class="code" href="class_t_c_p_status_info.html">TCPStatusInfo</a> *&gt;(msg-&gt;removeControlInfo());
00292              delete msg;
00293              if (cb)
00294                  cb-&gt;socketStatusArrived(connId, yourPtr, status);
00295              break;
00296         default:
00297              opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>: invalid msg kind %d, one of the TCP_I_xxx constants expected", msg-&gt;kind());
00298     }
00299 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z127_2" doxytag="TCPSocket::remoteAddress"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> TCPSocket::remoteAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00211 {<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_socket.html#p4">remoteAddr</a>;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z127_3" doxytag="TCPSocket::remotePort"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPSocket::remotePort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00212 {<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_socket.html#p5">remotePrt</a>;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_10" doxytag="TCPSocket::renewSocket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::renewSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Required to re-connect with a "used" TCPSocket object. By default, a TCPSocket object is tied to a single <a class="el" href="class_t_c_p.html">TCP</a> connection, via the connectionId. When the connection gets closed or aborted, you cannot use the socket to connect again (by <a class="el" href="class_t_c_p_socket.html#z129_5">connect()</a> or <a class="el" href="class_t_c_p_socket.html#z129_3">listen()</a>) unless you obtain a new connectionId by calling this method.<p>
BEWARE if you use TCPSocketMap! <a class="el" href="class_t_c_p_socket_map.html">TCPSocketMap</a> uses connectionId to find TCPSockets, so after calling this method you have to remove the socket from your <a class="el" href="class_t_c_p_socket_map.html">TCPSocketMap</a>, and re-add it. Otherwise <a class="el" href="class_t_c_p_socket_map.html">TCPSocketMap</a> will get confused.<p>
The reason why one must obtain a new connectionId is that <a class="el" href="class_t_c_p.html">TCP</a> still has to maintain the connection data structure (identified by the old connectionId) internally for a while (2 maximum segment lifetimes = 240s) after it reported "connection closed" to us. <div class="fragment"><pre class="fragment">00209 {
00210     <a class="code" href="class_t_c_p_socket.html#p0">connId</a> = ev.getUniqueNumber();
00211     <a class="code" href="class_t_c_p_socket.html#p4">remoteAddr</a> = <a class="code" href="class_t_c_p_socket.html#p2">localAddr</a> = <a class="code" href="class_i_pv_x_address.html">IPvXAddress</a>();
00212     <a class="code" href="class_t_c_p_socket.html#p5">remotePrt</a> = <a class="code" href="class_t_c_p_socket.html#p3">localPrt</a> = -1;
00213 
00214     <a class="code" href="class_t_c_p_socket.html#p1">sockstate</a> = <a class="code" href="class_t_c_p_socket.html#w9w0">NOT_BOUND</a>;
00215 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_9" doxytag="TCPSocket::requestStatus"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::requestStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Causes <a class="el" href="class_t_c_p.html">TCP</a> to reply with a fresh <a class="el" href="class_t_c_p_status_info.html">TCPStatusInfo</a>, attached to a dummy message as controlInfo(). The reply message can be recognized by its message kind TCP_I_STATUS, or (if a callback object is used) the socketStatusArrived() method of the callback object will be called. <div class="fragment"><pre class="fragment">00200 {
00201     cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">"STATUS"</span>, TCP_C_STATUS);
00202     <a class="code" href="class_t_c_p_command.html">TCPCommand</a> *cmd = <span class="keyword">new</span> <a class="code" href="class_t_c_p_command.html">TCPCommand</a>();
00203     cmd-&gt;<a class="code" href="class_t_c_p_command.html#a7">setConnId</a>(connId);
00204     msg-&gt;setControlInfo(cmd);
00205     <a class="code" href="class_t_c_p_socket.html#b0">sendToTCP</a>(msg);
00206 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_6" doxytag="TCPSocket::send"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends data packet. <div class="fragment"><pre class="fragment">00162 {
00163     <span class="keywordflow">if</span> (sockstate!=CONNECTED &amp;&amp; sockstate!=CONNECTING &amp;&amp; sockstate!=PEER_CLOSED)
00164         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>::send(): not connected or connecting");
00165 
00166     msg-&gt;setKind(TCP_C_SEND);
00167     <a class="code" href="class_t_c_p_send_command.html">TCPSendCommand</a> *cmd = new <a class="code" href="class_t_c_p_send_command.html">TCPSendCommand</a>();
00168     cmd-&gt;setConnId(connId);
00169     msg-&gt;setControlInfo(cmd);
00170     sendToTCP(msg);
00171 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="TCPSocket::sendToTCP"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::sendToTCP           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00087 {
00088     <span class="keywordflow">if</span> (!gateToTcp)
00089         opp_error("<a class="code" href="class_t_c_p_socket.html">TCPSocket</a>: setOutputGate() must be invoked before socket can be used");
00090 
00091     check_and_cast&lt;cSimpleModule *&gt;(gateToTcp-&gt;ownerModule())-&gt;send(msg, gateToTcp);
00092 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z131_1" doxytag="TCPSocket::setCallbackObject"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::setCallbackObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>yourPtr</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a callback object, to be used with <a class="el" href="class_t_c_p_socket.html#z131_2">processMessage()</a>. This callback object may be your simple module itself (if it multiply inherits from <a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a> too, that is you declared it as <pre>
 class MyAppModule : public cSimpleModule, public <a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">TCPSocket::CallbackInterface</a>
 </pre> and redefined the necessary virtual functions; or you may use dedicated class (and objects) for this purpose.<p>
TCPSocket doesn't delete the callback object in the destructor or on any other occasion.<p>
YourPtr is an optional pointer. It may contain any value you wish -- TCPSocket will not look at it or do anything with it except passing it back to you in the <a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a> calls. You may find it useful if you maintain additional per-connection information: in that case you don't have to look it up by connId in the callbacks, you can have it passed to you as yourPtr. <div class="fragment"><pre class="fragment">00229 {
00230     <a class="code" href="class_t_c_p_socket.html#p6">cb</a> = callback;
00231     <a class="code" href="class_t_c_p_socket.html#p7">yourPtr</a> = yourPointer;
00232 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z129_0" doxytag="TCPSocket::setOutputGate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPSocket::setOutputGate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cGate *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>toTcp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the gate on which to send to <a class="el" href="class_t_c_p.html">TCP</a>. Must be invoked before socket can be used. Example: <code>socket.setOutputGate(gate("tcpOut"));</code> <div class="fragment"><pre class="fragment">00222 {<a class="code" href="class_t_c_p_socket.html#p8">gateToTcp</a> = toTcp;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="TCPSocket::state"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPSocket::state           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the socket state, one of NOT_BOUND, CLOSED, LISTENING, CONNECTING, CONNECTED, etc. Messages received from <a class="el" href="class_t_c_p.html">TCP</a> must be routed through <a class="el" href="class_t_c_p_socket.html#z131_2">processMessage()</a> in order to keep socket state up-to-date. <div class="fragment"><pre class="fragment">00200 {<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_socket.html#p1">sockstate</a>;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="e0" doxytag="TCPSocket::stateName"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char * TCPSocket::stateName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns name of socket state code returned by <a class="el" href="class_t_c_p_socket.html#a4">state()</a>. <div class="fragment"><pre class="fragment">00067 {
00068 <span class="preprocessor">#define CASE(x) case x: s=#x; break</span>
00069 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">char</span> *s = <span class="stringliteral">"unknown"</span>;
00070     <span class="keywordflow">switch</span> (state)
00071     {
00072         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(NOT_BOUND);
00073         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(BOUND);
00074         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(LISTENING);
00075         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(CONNECTING);
00076         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(CONNECTED);
00077         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(PEER_CLOSED);
00078         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(LOCALLY_CLOSED);
00079         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(CLOSED);
00080         <a class="code" href="_ether_m_a_c_8cc.html#a0">CASE</a>(SOCKERROR);
00081     }
00082     <span class="keywordflow">return</span> s;
00083 <span class="preprocessor">#undef CASE</span>
00084 <span class="preprocessor"></span>}
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="p6" doxytag="TCPSocket::cb"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_t_c_p_socket_1_1_callback_interface.html">CallbackInterface</a>* <a class="el" href="class_t_c_p_socket.html#p6">TCPSocket::cb</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p0" doxytag="TCPSocket::connId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_t_c_p_socket.html#p0">TCPSocket::connId</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p8" doxytag="TCPSocket::gateToTcp"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">cGate* <a class="el" href="class_t_c_p_socket.html#p8">TCPSocket::gateToTcp</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p2" doxytag="TCPSocket::localAddr"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> <a class="el" href="class_t_c_p_socket.html#p2">TCPSocket::localAddr</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p3" doxytag="TCPSocket::localPrt"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_t_c_p_socket.html#p3">TCPSocket::localPrt</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p4" doxytag="TCPSocket::remoteAddr"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> <a class="el" href="class_t_c_p_socket.html#p4">TCPSocket::remoteAddr</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p5" doxytag="TCPSocket::remotePrt"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_t_c_p_socket.html#p5">TCPSocket::remotePrt</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p1" doxytag="TCPSocket::sockstate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_t_c_p_socket.html#p1">TCPSocket::sockstate</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p7" doxytag="TCPSocket::yourPtr"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* <a class="el" href="class_t_c_p_socket.html#p7">TCPSocket::yourPtr</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_t_c_p_socket_8h.html">TCPSocket.h</a><li><a class="el" href="_t_c_p_socket_8cc.html">TCPSocket.cc</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 18:22:31 2006 for INET Framework for OMNeT++/OMNEST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
