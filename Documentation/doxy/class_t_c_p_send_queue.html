<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>INET Framework for OMNeT++/OMNEST: TCPSendQueue Class Reference</title>
<link href="opp.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>TCPSendQueue Class Reference</h1><code>#include &lt;TCPSendQueue.h&gt;</code>
<p>
<p>Inheritance diagram for TCPSendQueue:
<p><center><img src="class_t_c_p_send_queue.png" usemap="#TCPSendQueue_map" border="0" alt=""></center>
<map name="TCPSendQueue_map">
<area href="class_t_c_p_msg_based_send_queue.html" alt="TCPMsgBasedSendQueue" shape="rect" coords="0,56,166,80">
<area href="class_t_c_p_virtual_data_send_queue.html" alt="TCPVirtualDataSendQueue" shape="rect" coords="176,56,342,80">
</map>
<a href="class_t_c_p_send_queue-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract base class for <a class="el" href="class_t_c_p.html">TCP</a> send queues. In fact a single object represents both the send queue and the retransmission queue (no need to separate them). The <a class="el" href="class_t_c_p_connection.html">TCPConnection</a> object knows which data in the queue have already been transmitted ("retransmission queue") and which not ("send queue"). This class is not interested in where's the boundary.<p>
There is another particularity about this class: as a retransmission queue, it stores bytes and not segments. <a class="el" href="class_t_c_p.html">TCP</a> is a bytestream oriented protocol (sequence numbers refer to bytes and not to TPDUs as e.g. in ISO TP4), and the protocol doesn't rely on retransmitted segments having the same segment boundaries as the original segments. Some implementations store segments on the retransmission queue, and others store only the data bytes; RFCs explicitly allow both. (See e.g. RFC1122 p90, section 4.2.2.15, "IMPLEMENTATION" note).<p>
To simulate a <a class="el" href="class_t_c_p.html">TCP</a> that retains segment boundaries in retransmissions, the appropriate <a class="el" href="class_t_c_p_algorithm.html">TCPAlgorithm</a> class should remember where the segment boundaries were at the original transmission, and it should form identical segments when retransmitting. The <a class="el" href="class_t_c_p_send_queue.html#a6">createSegmentWithBytes()</a> send queue method makes this possible.<p>
This class is polymorphic because depending on where and how you use the <a class="el" href="class_t_c_p.html">TCP</a> model you might have different ideas about "sending data" on a simulated connection.<p>
You might want to:<p>
<ul>
<li>transmit a real bytes, especially if the application which uses <a class="el" href="class_t_c_p.html">TCP</a> is a ported version of a real socket application.</li></ul>
<p>
<ul>
<li>simulate a "dummy" connection, that is, simulated <a class="el" href="class_t_c_p.html">TCP</a> segments contain do not contain any real data, only the number of bytes they represent. You'll want to do this when the app is there solely as a traffic generator (e.g. simulated file transfer or telnet session), but actual data is unimportant.</li></ul>
<p>
<ul>
<li>transmit a sequence of cMessage objects, and you want exactly the same cMessage sequence to be reproduced on the receiver side. Here every cMessage maps to a sequence number range in the <a class="el" href="class_t_c_p.html">TCP</a> stream, and the object is passed up to the application on the receiving side when its last byte has arrived on the simulated connection.</li></ul>
<p>
Different TCPSendQueue subclasses can be written to accomodate different needs.<p>
This class goes hand-in-hand with <a class="el" href="class_t_c_p_receive_queue.html">TCPReceiveQueue</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="class_t_c_p_receive_queue.html">TCPReceiveQueue</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a0">TCPSendQueue</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a1">~TCPSendQueue</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a2">init</a> (<a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a> startSeq)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a3">enqueueAppData</a> (cMessage *msg)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a4">bufferEndSeq</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_i_n_e_t_fw.html#a7">ulong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a5">bytesAvailable</a> (<a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a> fromSeq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_t_c_p_segment.html">TCPSegment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a6">createSegmentWithBytes</a> (<a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a> fromSeq, <a class="el" href="namespace_i_n_e_t_fw.html#a7">ulong</a> maxNumBytes)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_send_queue.html#a7">discardUpTo</a> (<a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a> seqNum)=0</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="TCPSendQueue::TCPSendQueue"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TCPSendQueue::TCPSendQueue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ctor. <div class="fragment"><pre class="fragment">00085 {}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="TCPSendQueue::~TCPSendQueue"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual TCPSendQueue::~<a class="el" href="class_t_c_p_send_queue.html">TCPSendQueue</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual dtor. <div class="fragment"><pre class="fragment">00090 {}
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a4" doxytag="TCPSendQueue::bufferEndSeq"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a> TCPSendQueue::bufferEndSeq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the sequence number of the last byte stored in the buffer plus one. (The first byte of the next send operation would get this sequence number.) 
<p>
Implemented in <a class="el" href="class_t_c_p_msg_based_send_queue.html#a5">TCPMsgBasedSendQueue</a>, and <a class="el" href="class_t_c_p_virtual_data_send_queue.html#a5">TCPVirtualDataSendQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="TCPSendQueue::bytesAvailable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="namespace_i_n_e_t_fw.html#a7">ulong</a> TCPSendQueue::bytesAvailable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fromSeq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Utility function: returns how many bytes are available in the queue, from (and including) the given sequence number. <div class="fragment"><pre class="fragment">00123     {
00124         <a class="code" href="_i_n_e_t_defs_8h.html#a6">uint32</a> bufEndSeq = <a class="code" href="class_t_c_p_send_queue.html#a4">bufferEndSeq</a>();
00125         <span class="keywordflow">return</span> <a class="code" href="_t_c_p_connection_8h.html#a36">seqLess</a>(fromSeq, bufEndSeq) ? bufEndSeq-fromSeq : 0;
00126     }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="TCPSendQueue::createSegmentWithBytes"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="class_t_c_p_segment.html">TCPSegment</a>* TCPSendQueue::createSegmentWithBytes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fromSeq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespace_i_n_e_t_fw.html#a7">ulong</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxNumBytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called when the <a class="el" href="class_t_c_p.html">TCP</a> wants to send or retransmit data, it constructs a <a class="el" href="class_t_c_p.html">TCP</a> segment which contains the data from the requested sequence number range. The actually returned segment may contain less then maxNumBytes bytes if the subclass wants to reproduce the original segment boundaries when retransmitting. 
<p>
Implemented in <a class="el" href="class_t_c_p_msg_based_send_queue.html#a6">TCPMsgBasedSendQueue</a>, and <a class="el" href="class_t_c_p_virtual_data_send_queue.html#a6">TCPVirtualDataSendQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="TCPSendQueue::discardUpTo"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void TCPSendQueue::discardUpTo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>seqNum</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells the queue that bytes up to (but NOT including) seqNum have been transmitted and ACKed, so they can be removed from the queue. 
<p>
Implemented in <a class="el" href="class_t_c_p_msg_based_send_queue.html#a7">TCPMsgBasedSendQueue</a>, and <a class="el" href="class_t_c_p_virtual_data_send_queue.html#a7">TCPVirtualDataSendQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="TCPSendQueue::enqueueAppData"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void TCPSendQueue::enqueueAppData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called on SEND app command, it inserts in the queue the data the user wants to send. Implementations of this abstract class will decide what this means: copying actual bytes, just increasing the "last byte queued" variable, or storing cMessage object(s). The msg object should not be referenced after this point (sendQueue may delete it.) 
<p>
Implemented in <a class="el" href="class_t_c_p_msg_based_send_queue.html#a4">TCPMsgBasedSendQueue</a>, and <a class="el" href="class_t_c_p_virtual_data_send_queue.html#a4">TCPVirtualDataSendQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="TCPSendQueue::init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void TCPSendQueue::init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="_i_n_e_t_defs_8h.html#a6">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>startSeq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the object. The startSeq parameter tells what sequence number the first byte of app data should get. This is usually ISS+1 because SYN consumes one byte in the sequence number space.<p>
<a class="el" href="class_t_c_p_send_queue.html#a2">init()</a> may be called more than once; every call flushes the existing contents of the queue. 
<p>
Implemented in <a class="el" href="class_t_c_p_msg_based_send_queue.html#a2">TCPMsgBasedSendQueue</a>, and <a class="el" href="class_t_c_p_virtual_data_send_queue.html#a2">TCPVirtualDataSendQueue</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_t_c_p_send_queue_8h.html">TCPSendQueue.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 18:22:31 2006 for INET Framework for OMNeT++/OMNEST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
