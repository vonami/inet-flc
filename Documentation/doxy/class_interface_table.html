<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>INET Framework for OMNeT++/OMNEST: InterfaceTable Class Reference</title>
<link href="opp.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>InterfaceTable Class Reference</h1><code>#include &lt;InterfaceTable.h&gt;</code>
<p>
<p>Inheritance diagram for InterfaceTable:
<p><center><img src="class_interface_table.png" usemap="#InterfaceTable_map" border="0" alt=""></center>
<map name="InterfaceTable_map">
<area href="class_i_notifiable.html" alt="INotifiable" shape="rect" coords="0,0,93,24">
</map>
<a href="class_interface_table-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Represents the interface table. This object has one instance per host or router. It has methods to manage the interface table, so one can access functionality similar to the "ifconfig" command.<p>
See the NED documentation for general overview.<p>
This is a simple module without gates, it requires function calls to it (message handling does nothing). Methods are provided for reading and updating the interface table.<p>
Interfaces are dynamically registered: at the start of the simulation, every L2 module adds its own <a class="el" href="class_interface_entry.html">InterfaceEntry</a> to the table; after that, IPv4's <a class="el" href="class_routing_table.html">RoutingTable</a> and IPv6's <a class="el" href="class_routing_table6.html">RoutingTable6</a> (an possibly, further L3 protocols) add protocol-specific data on each <a class="el" href="class_interface_entry.html">InterfaceEntry</a> (see <a class="el" href="class_i_pv4_interface_data.html">IPv4InterfaceData</a>, <a class="el" href="class_i_pv6_interface_data.html">IPv6InterfaceData</a>, and <a class="el" href="class_interface_entry.html#a37">InterfaceEntry::setIPv4Data()</a>, <a class="el" href="class_interface_entry.html#a38">InterfaceEntry::setIPv6Data()</a>)<p>
Interfaces are represented by <a class="el" href="class_interface_entry.html">InterfaceEntry</a> objects.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="class_interface_entry.html">InterfaceEntry</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a0">InterfaceTable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a1">~InterfaceTable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a2">receiveChangeNotification</a> (int category, cPolymorphic *details)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a3">addInterface</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *entry, cModule *ifmod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a4">numInterfaces</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a5">interfaceAt</a> (int pos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a6">interfaceByNodeOutputGateId</a> (int id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a7">interfaceByNodeInputGateId</a> (int id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a8">interfaceByNetworkLayerGateIndex</a> (int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a9">interfaceByName</a> (const char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#a10">firstLoopbackInterface</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#b0">updateDisplayString</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#b1">discoverConnectingGates</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *entry, cModule *ifmod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#b2">numInitStages</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#b3">initialize</a> (int stage)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#b4">handleMessage</a> (cMessage *)</td></tr>

<tr><td colspan="2"><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_interface_entry.html">InterfaceEntry</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#y0">InterfaceVector</a></td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_notification_board.html">NotificationBoard</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#r0">nb</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_interface_table.html#y0">InterfaceVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_table.html#r1">interfaces</a></td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="y0" doxytag="InterfaceTable::InterfaceVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef std::vector&lt;<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&gt; <a class="el" href="class_interface_table.html#y0">InterfaceTable::InterfaceVector</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="InterfaceTable::InterfaceTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">InterfaceTable::InterfaceTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00041 {
00042 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="InterfaceTable::~InterfaceTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">InterfaceTable::~<a class="el" href="class_interface_table.html">InterfaceTable</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00045 {
00046     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="class_interface_table.html#r1">interfaces</a>.size(); i++)
00047         <span class="keyword">delete</span> <a class="code" href="class_interface_table.html#r1">interfaces</a>[i];
00048 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a3" doxytag="InterfaceTable::addInterface"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InterfaceTable::addInterface           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>cModule *&nbsp;</td>
          <td class="mdname" nowrap> <em>ifmod</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds an interface. The second argument should be a module which belongs to the physical interface (e.g. <a class="el" href="class_p_p_p.html">PPP</a> or EtherMac) -- it will be used to discover and fill in networkLayerGateIndex(), nodeOutputGateId(), and nodeInputGateId() in <a class="el" href="class_interface_entry.html">InterfaceEntry</a>. It should be NULL if this is a virtual interface (e.g. loopback).<p>
Note: Interface deletion is not supported, but one can mark one as "down". <div class="fragment"><pre class="fragment">00105 {
00106     <span class="comment">// check name is unique</span>
00107     <span class="keywordflow">if</span> (<a class="code" href="class_interface_table.html#a9">interfaceByName</a>(entry-&gt;<a class="code" href="class_interface_entry.html#a5">name</a>())!=NULL)
00108         opp_error(<span class="stringliteral">"addInterface(): interface '%s' already registered"</span>, entry-&gt;<a class="code" href="class_interface_entry.html#a5">name</a>());
00109 
00110     <span class="comment">// insert</span>
00111     entry-&gt;<a class="code" href="class_interface_entry.html#r0">_interfaceId</a> = <a class="code" href="class_interface_table.html#r1">interfaces</a>.size();
00112     <a class="code" href="class_interface_table.html#r1">interfaces</a>.push_back(entry);
00113 
00114     <span class="comment">// fill in networkLayerGateIndex, nodeOutputGateId, nodeInputGateId</span>
00115     <span class="keywordflow">if</span> (ifmod)
00116         discoverConnectingGates(entry, ifmod);
00117 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="InterfaceTable::discoverConnectingGates"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InterfaceTable::discoverConnectingGates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>cModule *&nbsp;</td>
          <td class="mdname" nowrap> <em>ifmod</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00120 {
00121     <span class="comment">// ifmod is something like "host.eth[1].mac"; climb up to find "host.eth[1]" from it</span>
00122     cModule *host = parentModule();
00123     <span class="keywordflow">while</span> (ifmod &amp;&amp; ifmod-&gt;parentModule()!=host)
00124         ifmod = ifmod-&gt;parentModule();
00125     <span class="keywordflow">if</span> (!ifmod)
00126         opp_error("addInterface(): specified module is not in this host/router");
00127 
00128     <span class="comment">// find gates connected to host / network layer</span>
00129     cGate *nwlayerInGate=NULL, *nwlayerOutGate=NULL;
00130     for (<span class="keywordtype">int</span> i=0; i&lt;ifmod-&gt;gates(); i++)
00131     {
00132         cGate *g = ifmod-&gt;gate(i);
00133         <span class="keywordflow">if</span> (!g) continue;
00134 
00135         <span class="comment">// find the host/router's gates that internally connect to this interface</span>
00136         if (g-&gt;type()=='O' &amp;&amp; g-&gt;toGate() &amp;&amp; g-&gt;toGate()-&gt;ownerModule()==host)
00137             entry-&gt;setNodeOutputGateId(g-&gt;toGate()-&gt;<span class="keywordtype">id</span>());
00138         if (g-&gt;type()=='I' &amp;&amp; g-&gt;fromGate() &amp;&amp; g-&gt;fromGate()-&gt;ownerModule()==host)
00139             entry-&gt;setNodeInputGateId(g-&gt;fromGate()-&gt;<span class="keywordtype">id</span>());
00140 
00141         <span class="comment">// find the gate index of networkLayer/networkLayer6/mpls that connects to this interface</span>
00142         if (g-&gt;type()=='O' &amp;&amp; g-&gt;toGate() &amp;&amp; g-&gt;toGate()-&gt;isName("ifIn"))
00143             nwlayerInGate = g-&gt;toGate();
00144         if (g-&gt;type()=='I' &amp;&amp; g-&gt;fromGate() &amp;&amp; g-&gt;fromGate()-&gt;isName("ifOut"))
00145             nwlayerOutGate = g-&gt;fromGate();
00146     }
00147 
00148     <span class="comment">// consistency checks</span>
00149     <span class="comment">// note: we don't check nodeOutputGateId/nodeInputGateId, because wireless interfaces</span>
00150     <span class="comment">// are not connected to the host</span>
00151     if (!nwlayerInGate || !nwlayerOutGate || nwlayerInGate-&gt;index()!=nwlayerOutGate-&gt;index())
00152         opp_error("addInterface(): interface must be connected to network layer's ifIn[]/ifOut[] gates of the same index");
00153     entry-&gt;setNetworkLayerGateIndex(nwlayerInGate-&gt;index());
00154 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="InterfaceTable::firstLoopbackInterface"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * InterfaceTable::firstLoopbackInterface           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the first interface with the isLoopback flag set. (If there's no loopback, it returns NULL -- but this should never happen because InterfaceTable itself registers a loopback interface on startup.) <div class="fragment"><pre class="fragment">00213 {
00214     Enter_Method_Silent();
00215 
00216     <span class="keywordflow">for</span> (InterfaceVector::iterator i=<a class="code" href="class_interface_table.html#r1">interfaces</a>.begin(); i!=<a class="code" href="class_interface_table.html#r1">interfaces</a>.end(); ++i)
00217         <span class="keywordflow">if</span> ((*i)-&gt;isLoopback())
00218             <span class="keywordflow">return</span> *i;
00219     <span class="keywordflow">return</span> NULL;
00220 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b4" doxytag="InterfaceTable::handleMessage"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InterfaceTable::handleMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">cMessage *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Raises an error. <div class="fragment"><pre class="fragment">00082 {
00083     opp_error(<span class="stringliteral">"This module doesn't process messages"</span>);
00084 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b3" doxytag="InterfaceTable::initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InterfaceTable::initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>stage</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00051 {
00052     <span class="keywordflow">if</span> (stage==0)
00053     {
00054         <span class="comment">// get a pointer to the NotificationBoard module</span>
00055         <a class="code" href="class_interface_table.html#r0">nb</a> = <a class="code" href="class_notification_board_access.html">NotificationBoardAccess</a>().get();
00056 
00057         <span class="comment">// register a loopback interface</span>
00058         <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <span class="keyword">new</span> <a class="code" href="class_interface_entry.html">InterfaceEntry</a>();
00059         ie-&gt;<a class="code" href="class_interface_entry.html#a19">setName</a>(<span class="stringliteral">"lo0"</span>);
00060         ie-&gt;<a class="code" href="class_interface_entry.html#a24">setMtu</a>(3924);
00061         ie-&gt;<a class="code" href="class_interface_entry.html#a29">setLoopback</a>(<span class="keyword">true</span>);
00062         <a class="code" href="class_interface_table.html#a3">addInterface</a>(ie, NULL);
00063     }
00064     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stage==1)
00065     {
00066         WATCH_PTRVECTOR(interfaces);
00067         <a class="code" href="class_interface_table.html#b0">updateDisplayString</a>();
00068     }
00069 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="InterfaceTable::interfaceAt"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * InterfaceTable::interfaceAt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pos</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the <a class="el" href="class_interface_entry.html">InterfaceEntry</a> specified by an index 0..numInterfaces-1. <div class="fragment"><pre class="fragment">00096 {
00097     <span class="keywordflow">if</span> (pos==-1) <span class="comment">// -1 is commonly used as "none"</span>
00098         return NULL;
00099     if (pos&lt;0 || pos&gt;=(<span class="keywordtype">int</span>)interfaces.size())
00100         opp_error("interfaceAt(): nonexistent interface %d", pos);
00101     return interfaces[pos];
00102 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="InterfaceTable::interfaceByName"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * InterfaceTable::interfaceByName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an interface given by its name. Returns NULL if not found. <div class="fragment"><pre class="fragment">00201 {
00202     Enter_Method_Silent();
00203 
00204     <span class="keywordflow">if</span> (!name)
00205         return NULL;
00206     for (InterfaceVector::iterator i=interfaces.begin(); i!=interfaces.end(); ++i)
00207         if (!strcmp(name, (*i)-&gt;name()))
00208             return *i;
00209     return NULL;
00210 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="InterfaceTable::interfaceByNetworkLayerGateIndex"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * InterfaceTable::interfaceByNetworkLayerGateIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an interface given by its networkLayerGateIndex(). Returns NULL if not found. <div class="fragment"><pre class="fragment">00191 {
00192     <span class="comment">// linear search is OK because normally we have don't have many interfaces and this func is rarely called</span>
00193     Enter_Method_Silent();
00194     <span class="keywordflow">for</span> (InterfaceVector::iterator i=<a class="code" href="class_interface_table.html#r1">interfaces</a>.begin(); i!=<a class="code" href="class_interface_table.html#r1">interfaces</a>.end(); ++i)
00195         <span class="keywordflow">if</span> ((*i)-&gt;networkLayerGateIndex()==index)
00196             <span class="keywordflow">return</span> *i;
00197     <span class="keywordflow">return</span> NULL;
00198 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="InterfaceTable::interfaceByNodeInputGateId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * InterfaceTable::interfaceByNodeInputGateId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an interface given by its nodeInputGateId(). Returns NULL if not found. <div class="fragment"><pre class="fragment">00181 {
00182     <span class="comment">// linear search is OK because normally we have don't have many interfaces and this func is rarely called</span>
00183     Enter_Method_Silent();
00184     <span class="keywordflow">for</span> (InterfaceVector::iterator i=<a class="code" href="class_interface_table.html#r1">interfaces</a>.begin(); i!=<a class="code" href="class_interface_table.html#r1">interfaces</a>.end(); ++i)
00185         <span class="keywordflow">if</span> ((*i)-&gt;nodeInputGateId()==id)
00186             <span class="keywordflow">return</span> *i;
00187     <span class="keywordflow">return</span> NULL;
00188 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="InterfaceTable::interfaceByNodeOutputGateId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * InterfaceTable::interfaceByNodeOutputGateId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an interface given by its nodeOutputGateId(). Returns NULL if not found. <div class="fragment"><pre class="fragment">00171 {
00172     <span class="comment">// linear search is OK because normally we have don't have many interfaces and this func is rarely called</span>
00173     Enter_Method_Silent();
00174     <span class="keywordflow">for</span> (InterfaceVector::iterator i=<a class="code" href="class_interface_table.html#r1">interfaces</a>.begin(); i!=<a class="code" href="class_interface_table.html#r1">interfaces</a>.end(); ++i)
00175         <span class="keywordflow">if</span> ((*i)-&gt;nodeOutputGateId()==id)
00176             <span class="keywordflow">return</span> *i;
00177     <span class="keywordflow">return</span> NULL;
00178 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b2" doxytag="InterfaceTable::numInitStages"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int InterfaceTable::numInitStages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00071 {<span class="keywordflow">return</span> 2;}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="InterfaceTable::numInterfaces"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int InterfaceTable::numInterfaces           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of interfaces. <div class="fragment"><pre class="fragment">00101 {<span class="keywordflow">return</span> <a class="code" href="class_interface_table.html#r1">interfaces</a>.size();}
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="InterfaceTable::receiveChangeNotification"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InterfaceTable::receiveChangeNotification           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>category</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>cPolymorphic *&nbsp;</td>
          <td class="mdname" nowrap> <em>details</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called by the <a class="el" href="class_notification_board.html">NotificationBoard</a> whenever a change of a category occurs to which this client has subscribed. 
<p>
Implements <a class="el" href="class_i_notifiable.html#a1">INotifiable</a>.<div class="fragment"><pre class="fragment">00087 {
00088     <span class="comment">// nothing needed here at the moment</span>
00089     Enter_Method_Silent();
00090     <a class="code" href="_notifier_consts_8cc.html#a1">printNotificationBanner</a>(category, details);
00091 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="InterfaceTable::updateDisplayString"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InterfaceTable::updateDisplayString           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">00072 {
00073     <span class="keywordflow">if</span> (!ev.isGUI())
00074         <span class="keywordflow">return</span>;
00075 
00076     <span class="keywordtype">char</span> buf[80];
00077     sprintf(buf, <span class="stringliteral">"%d interfaces"</span>, <a class="code" href="class_interface_table.html#r1">interfaces</a>.size());
00078     displayString().setTagArg(<span class="stringliteral">"t"</span>,0,buf);
00079 }
</pre></div>
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="r1" doxytag="InterfaceTable::interfaces"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_interface_table.html#y0">InterfaceVector</a> <a class="el" href="class_interface_table.html#r1">InterfaceTable::interfaces</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r0" doxytag="InterfaceTable::nb"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_notification_board.html">NotificationBoard</a>* <a class="el" href="class_interface_table.html#r0">InterfaceTable::nb</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_interface_table_8h.html">InterfaceTable.h</a><li><a class="el" href="_interface_table_8cc.html">InterfaceTable.cc</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 18:22:24 2006 for INET Framework for OMNeT++/OMNEST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
