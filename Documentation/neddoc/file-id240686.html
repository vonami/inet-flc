<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h2 class="comptitle">File <i>NetworkInterfaces/Ethernet/eth-index.ned</i>
</h2>
<h3 class="subtitle">Contains:</h3>
<ul></ul>
<pre class="src"><span class="src-comment">//</span>
<span class="src-comment">// Copyright (C) 2003 CTIE, Monash University</span>
<span class="src-comment">//</span>
<span class="src-comment">// This program is free software; you can redistribute it and/or</span>
<span class="src-comment">// modify it under the terms of the GNU General Public License</span>
<span class="src-comment">// as published by the Free Software Foundation; either version 2</span>
<span class="src-comment">// of the License, or (at your option) any later version.</span>
<span class="src-comment">//</span>
<span class="src-comment">// This program is distributed in the hope that it will be useful,</span>
<span class="src-comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="src-comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="src-comment">// GNU General Public License for more details.</span>
<span class="src-comment">//</span>
<span class="src-comment">// You should have received a copy of the GNU General Public License</span>
<span class="src-comment">// along with this program; if not, write to the Free Software</span>
<span class="src-comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="src-comment">//</span>


<span class="src-comment">//# @-titlepage (would conflict with main titlepage)</span>
<span class="src-comment">//# &lt;h1&gt;Ethernet Model Documentation&lt;/h1&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page eth-index.html, Ethernet Model -- Start Page</span>
<span class="src-comment">//</span>
<span class="src-comment">//# This documents the Ethernet model created by David Wu and refined by Andras</span>
<span class="src-comment">//# Varga at CTIE, Monash University, Melbourne, Australia.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The Ethernet model contains a MAC model (EtherMAC), LLC model (EtherLLC) as well</span>
<span class="src-comment">// as a bus (EtherBus, for modelling coaxial \cable) and a hub (EtherHub) model.</span>
<span class="src-comment">// A switch model (EtherSwitch) is also provided.</span>
<span class="src-comment">//</span>
<span class="src-comment">// A few useful topics:</span>
<span class="src-comment">//  - &lt;a href="ether-overview.html"&gt;model overview&lt;/a&gt;</span>
<span class="src-comment">//  - &lt;a href="eth-standards.html"&gt;implemented standards&lt;/a&gt;</span>
<span class="src-comment">//  - &lt;a href="llc-app.html"&gt;communication between LLC and higher layers&lt;/a&gt;</span>
<span class="src-comment">//  - &lt;a href="appreg.html"&gt;application registration&lt;/a&gt;</span>
<span class="src-comment">//  - &lt;a href="physical.html"&gt;physical layer messaging&lt;/a&gt;</span>
<span class="src-comment">//  - click &lt;i&gt;selected topics&lt;/i&gt; in the navigation frame to see more topics</span>
<span class="src-comment">//</span>
<span class="src-comment">// If you can't wait to see the model, start here:</span>
<span class="src-comment">//  - the MixedLAN model contains hosts, switch, hub and bus;</span>
<span class="src-comment">//  - the &lt;a href="largenet.html"&gt;\LargeNet model&lt;/a&gt; contains hundreds of</span>
<span class="src-comment">//    computers, switches and hubs (numbers depend on model configuration in</span>
<span class="src-comment">//    largenet.ini), and mixes all kinds of Ethernet technologies;</span>
<span class="src-comment">//  - EtherHost is a sample node with an Ethernet NIC;</span>
<span class="src-comment">//  - EtherSwitch, EtherBus, EtherHub model switching hub, repeating hub and</span>
<span class="src-comment">//    the old coxial \cable;</span>
<span class="src-comment">//  - basic compnents of the model: EtherMAC, EtherLLC/EtherEncap module types,</span>
<span class="src-comment">//    MACRelayUnit (MACRelayUnitNP and MACRelayUnitPP), EtherFrame message type,</span>
<span class="src-comment">//    MACAddress class</span>
<span class="src-comment">//</span>
<span class="src-comment">// Related documentation:</span>
<span class="src-comment">//   - &lt;a href="../doxy/index.html" target="_top"&gt;C++ source documentation&lt;/a&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page ether-overview.html, Ethernet Model Overview</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Data packets and Ethernet frames&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// Ethernet frames carry data packets as encapsulated cMessage objects.</span>
<span class="src-comment">// Data packets can be of any message type (cMessage or cMessage subclass).</span>
<span class="src-comment">//</span>
<span class="src-comment">// The model encapsulates data packets in Ethernet frames using the &lt;tt&gt;encapsulate()&lt;/tt&gt;</span>
<span class="src-comment">// method of cMessage. Encapsulate() updates the length of the Ethernet frame too,</span>
<span class="src-comment">// so the model doesn't have to take care of that.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The models supports various Ethernet frame types: Ethernet II, 803.2 with</span>
<span class="src-comment">// LLC header, and 803.3 with LLC and SNAP headers. The corresponding classes are:</span>
<span class="src-comment">// EthernetIIFrame, EtherFrameWithLLC and EtherFrameWithSNAP. They all class</span>
<span class="src-comment">// from EtherFrame which only represents the basic MAC frame with source and</span>
<span class="src-comment">// destination addresses. EtherMAC only deals with EtherFrames, and does not</span>
<span class="src-comment">// care about the specific subclass.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Autoconfiguration&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// In order to facilitate building large models, EtherMAC and other Ethernet model</span>
<span class="src-comment">// components provide some degree of auto-configuration. Specifically, transmission</span>
<span class="src-comment">// rate and half duplex/full duplex mode can be chosen automatically so that</span>
<span class="src-comment">// connecting Ethernet MACs have matching settings. The purpose is similar to</span>
<span class="src-comment">// Ethernet Auto-Negotiation; however the mechanism is NOT a model of</span>
<span class="src-comment">// Auto-Negotiation (e.g. EtherBus and EtherHub also actively participate,</span>
<span class="src-comment">// which obviously does not happen in a real Ethernet.)</span>
<span class="src-comment">//</span>
<span class="src-comment">// What it does:</span>
<span class="src-comment">//  - the txrate parameters of EtherMAC represent the highest speed supported</span>
<span class="src-comment">//    by that station, or 0 for full autoconfiguration. Autoconfig will choose</span>
<span class="src-comment">//    the largest common denominator (the speed of the slowest station in the</span>
<span class="src-comment">//    collision domain) for all stations. If all stations are set to auto</span>
<span class="src-comment">//    txrate, 100Mb will be chosen, or 10Mb if there's a bus (EtherBus) in</span>
<span class="src-comment">//    the collision domain.</span>
<span class="src-comment">//  - the duplexEnabled parameter of EtherMAC means whether the station supports</span>
<span class="src-comment">//    duplex operation. However, duplex operation will actually be chosen only</span>
<span class="src-comment">//    if it's a DTE-to-DTE direct connection (there's no shared media like</span>
<span class="src-comment">//    EtherHub or EtherBus) and both sides have duplexEnabled=true set.</span>
<span class="src-comment">//</span>
<span class="src-comment">// How it works:</span>
<span class="src-comment">//</span>
<span class="src-comment">// Auto-configuration occurs at the beginning of the simulation, by</span>
<span class="src-comment">// Ethernet model components (EtherMAC, EtherHub and EtherBus) exchanging</span>
<span class="src-comment">// EtherAutoconfig messages with each other. See description of EtherAutoconfig</span>
<span class="src-comment">// for more info.</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;MAC and higher layers&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// MAC and LLC are implemented as separate modules (EtherMAC and</span>
<span class="src-comment">// EtherLLC/EtherEncap) because encapsulation/decapsulation functionality</span>
<span class="src-comment">// is not always needed. (Switches don't do encapsulation/decapsulation.)</span>
<span class="src-comment">// In switches, EtherMAC is used with MACRelayUnit.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;EtherLLC and higher layers&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// The EtherLLC module can serve several applications (higher layer protocols),</span>
<span class="src-comment">// and dispatch data to them. Higher layers are identified by DSAP.</span>
<span class="src-comment">// See &lt;a href="appreg.html"&gt;Application registration&lt;/a&gt; for more info.</span>
<span class="src-comment">//</span>
<span class="src-comment">// EtherEncap doesn't have the functionality to dispatch to different</span>
<span class="src-comment">// higher layers because in practice it'll always be used with IP.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page eth-standards.html, Ethernet: Implemented Standards</span>
<span class="src-comment">//</span>
<span class="src-comment">// The Ethernet model operates according to the following standards:</span>
<span class="src-comment">// - Gigabit Ethernet: IEEE 802.3z-1998</span>
<span class="src-comment">// - Full-Duplex Ethernet with Flow Control: IEEE 802.3x-1997</span>
<span class="src-comment">// - Fast Ethernet: IEEE 802.3u-1995</span>
<span class="src-comment">// - Ethernet: IEEE 802.3-1998</span>
<span class="src-comment">//</span>
<span class="src-comment">// Note: switches don't implement the Spanning Tree Protocol. You need to</span>
<span class="src-comment">// avoid cycles in the LAN topology.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page llc-app.html, Ethernet: Communication between LLC and Higher Layers</span>
<span class="src-comment">//</span>
<span class="src-comment">// Higher layers (applications or protocols) talk to the EtherLLC module.</span>
<span class="src-comment">//</span>
<span class="src-comment">// When a higher layer wants to send a packet via Ethernet, it just</span>
<span class="src-comment">// passes the data packet (a cMessage or any subclass) to EtherLLC.</span>
<span class="src-comment">// The message kind has to be set to IEEE802CTRL_DATA.</span>
<span class="src-comment">//</span>
<span class="src-comment">// In general, if EtherLLC receives a packet from the higher layers,</span>
<span class="src-comment">// it interprets the message kind as a command. The commands include</span>
<span class="src-comment">// IEEE802CTRL_DATA (send a frame), IEEE802CTRL_REGISTER_DSAP (register highher layer)</span>
<span class="src-comment">// IEEE802CTRL_DEREGISTER_DSAP (deregister higher layer) and IEEE802CTRL_SENDPAUSE</span>
<span class="src-comment">// (send PAUSE frame) -- see EtherLLC for a more complete list.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The arguments to the command are NOT inside the data packet but</span>
<span class="src-comment">// in a "control info" data structure of class Ieee802Ctrl, attached to</span>
<span class="src-comment">// the packet. See controlInfo() method of cMessage (OMNeT++ 3.0).</span>
<span class="src-comment">//</span>
<span class="src-comment">// For example, to send a packet to a given MAC address and protocol</span>
<span class="src-comment">// identifier, the application sets the data packet's message kind</span>
<span class="src-comment">// to ETH_DATA ("please send this data packet" command),</span>
<span class="src-comment">// fills in the Ieee802Ctrl structure with the destination MAC address and</span>
<span class="src-comment">// the protocol identifier, adds the control info to the message, then sends</span>
<span class="src-comment">// the packet to EtherLLC.</span>
<span class="src-comment">//</span>
<span class="src-comment">// When the command doesn't involve a data packet (e.g.</span>
<span class="src-comment">// IEEE802CTRL_(DE)REGISTER_DSAP, IEEE802CTRL_SENDPAUSE), a dummy packet</span>
<span class="src-comment">// (empty cMessage) is used.</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Rationale&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// The alternative of the above communications would be:</span>
<span class="src-comment">// - adding the parameters such as destination address into the data</span>
<span class="src-comment">//   packet. This would be a poor solution since it would make the</span>
<span class="src-comment">//   higher layers specific to the Ethernet model.</span>
<span class="src-comment">// - encapsulating a data packet into an &lt;i&gt;interface packet&lt;/i&gt; which</span>
<span class="src-comment">//   contains the destination address and other parameters. The</span>
<span class="src-comment">//   disadvantages of this approach is the overhead associated with</span>
<span class="src-comment">//   creating and destroying the interface packets.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Using a control structure is more efficient than the interface packet</span>
<span class="src-comment">// approach, because the control structure can be created once inside</span>
<span class="src-comment">// the higher layer and be reused for every packet.</span>
<span class="src-comment">//</span>
<span class="src-comment">// It may also appear to be more intuitive in Tkenv because one can observe</span>
<span class="src-comment">// data packets travelling between the higher layer and Ethernet</span>
<span class="src-comment">// modules -- as opposed to "interface" packets.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page appreg.html, EtherLLC: SAP Registration</span>
<span class="src-comment">//</span>
<span class="src-comment">// The Ethernet model supports multiple applications or higher layer</span>
<span class="src-comment">// protocols.</span>
<span class="src-comment">//</span>
<span class="src-comment">// So that data arriving from the network can be dispatched to the</span>
<span class="src-comment">// correct applications (higher layer protocols), applications</span>
<span class="src-comment">// have to register themselves in EtherLLC. The registration</span>
<span class="src-comment">// is done with the IEEE802CTRL_REGISTER_DSAP command</span>
<span class="src-comment">// (see &lt;a href="llc-app.html"&gt;communication between LLC and higher layers&lt;/a&gt;)</span>
<span class="src-comment">// which associates a SAP with the LLC port. Different applications</span>
<span class="src-comment">// have to connect to different ports of EtherLLC.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The ETHERCTRL_REGISTER_DSAP/IEEE802CTRL_DEREGISTER_DSAP commands use only the</span>
<span class="src-comment">// dsap field in the Ieee802Ctrl structure.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page physical.html, Ethernet: Messaging on the Physical Layer</span>
<span class="src-comment">//</span>
<span class="src-comment">// Messages sent by EtherMAC mark the beginning of a transmission.</span>
<span class="src-comment">// The end of a transmission is not explicitly represented by a message,</span>
<span class="src-comment">// but instead, the EtherMAC calculates it from the frame length and</span>
<span class="src-comment">// the transmission rate. Frames are represented by EtherFrame, with</span>
<span class="src-comment">// message kind=ETH_FRAME.</span>
<span class="src-comment">//</span>
<span class="src-comment">// When frames collide, the transmission is aborted -- in this case</span>
<span class="src-comment">// EtherMAC makes use of the modelled jam signals to figure out</span>
<span class="src-comment">// when colliding transmissions end.</span>
<span class="src-comment">//</span>
<span class="src-comment">// When a transmitting station senses a collision, it transmits a jam signal.</span>
<span class="src-comment">// Jam signals are represented by a message with kind=JAM_SIGNAL.</span>
<span class="src-comment">// When EtherMAC received a jam signal, it knows that one transmission</span>
<span class="src-comment">// has ended in jamming -- thus when it receives as many jam messages</span>
<span class="src-comment">// as colliding frames, it can be sure all transmissions have been aborted.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Receiving a jam message marks the beginning (and not the end)</span>
<span class="src-comment">// of a jam signal, so actually EtherMAC has to wait for the duration</span>
<span class="src-comment">// of the jamming before assuming the channel is free again.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page ether-pause.html, Ethernet: PAUSE handling</span>
<span class="src-comment">//</span>
<span class="src-comment">// The 802.3x standard supports PAUSE frames as a means of flow</span>
<span class="src-comment">// control. The frame contains a timer value, expressed as a multiple</span>
<span class="src-comment">// of 512 bit-times, that specifies how long the transmitter should</span>
<span class="src-comment">// remain quiet. If the receiver becomes uncongested before the</span>
<span class="src-comment">// transmitter's pause timer expires, the receiver may elect to send</span>
<span class="src-comment">// another Pause frame to the transmitter with a timer value of zero,</span>
<span class="src-comment">// allowing the transmitter to resume immediately.</span>
<span class="src-comment">//</span>
<span class="src-comment">// EtherMAC will properly respond to PAUSE frames it receives</span>
<span class="src-comment">// (EtherPauseFrame class, ETH_PAUSE message kind),</span>
<span class="src-comment">// however it will never send a PAUSE frame by itself. (For one thing,</span>
<span class="src-comment">// it doesn't have an input buffer that can overflow.)</span>
<span class="src-comment">//</span>
<span class="src-comment">// EtherMAC, however, transmits PAUSE frames received by higher layers,</span>
<span class="src-comment">// and EtherLLC can be instructed by a command to send a PAUSE frame to MAC.</span>
<span class="src-comment">//</span>
<span class="src-comment">// MACRelayUnit types (and thus EtherSwitch) currently implement a very simple</span>
<span class="src-comment">// scheme for sending PAUSE frames -- this can be refined if the need arises.</span>
<span class="src-comment">//</span>
<span class="src-comment">// For background on PAUSE, see e.g.</span>
<span class="src-comment">// http://www.computer.org/proceedings/lcn/0309/03090160abs.htm,</span>
<span class="src-comment">// http://www.nwfusion.com/netresources/0913flow.html, and</span>
<span class="src-comment">// http://www.nwfusion.com/netresources/0913flow2.html.</span>
<span class="src-comment">//</span>


<span class="src-comment">//</span>
<span class="src-comment">// @page largenet.html, LargeNet model description</span>
<span class="src-comment">//</span>
<span class="src-comment">// The LargeNet model demonstrates how one can put together models of large</span>
<span class="src-comment">// LANs with little effort, making use of MAC auto-configuration.</span>
<span class="src-comment">//</span>
<span class="src-comment">// LargeNet models a large Ethernet campus backbone. As configured in the</span>
<span class="src-comment">// default omnetpp.ini, it contains altogether about 8000 computers</span>
<span class="src-comment">// and 900 switches and hubs. This results in about 165MB process size</span>
<span class="src-comment">// on my (32-bit) linux box when I run the simulation.</span>
<span class="src-comment">// The model mixes all kinds of Ethernet technology: Gigabit Ethernet,</span>
<span class="src-comment">// 100Mb full duplex, 100Mb half duplex, 10Mb UTP, 10Mb bus ("thin Ethernet"),</span>
<span class="src-comment">// switched hubs, repeating hubs.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The topology is in LargeNet.ned, and it looks like this: there's chain</span>
<span class="src-comment">// of n=15 large "backbone" switches (switchBB[]) as well as four more</span>
<span class="src-comment">// large switches (switchA, switchB, switchC, switchD) connected to</span>
<span class="src-comment">// somewhere the middle of the backbone (switchBB[4]). These 15+4 switches</span>
<span class="src-comment">// make up the backbone; the n=15 number is configurable in omnetpp.ini.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Then there're several smaller LANs hanging off each backbone switch.</span>
<span class="src-comment">// There're three types of LANs: small, medium and large (represented by</span>
<span class="src-comment">// compound module types SmallLAN, MediumLAN, LargeLAN). A small LAN</span>
<span class="src-comment">// consists of a few computers on a hub (100Mb half duplex); a medium</span>
<span class="src-comment">// LAN consists of a smaller switch with a hub on one of its port</span>
<span class="src-comment">// (and computers on both); the large one also has a switch and a hub,</span>
<span class="src-comment">// plus an Ethernet bus hanging of one port of the hub (there's still hubs</span>
<span class="src-comment">// around with one BNC connector besides the UTP ones).</span>
<span class="src-comment">// By default there're 5..15 LANs of each type hanging off each backbone</span>
<span class="src-comment">// switch. (These numbers are also omnetpp.ini parameters like the length</span>
<span class="src-comment">// of the backbone.)</span>
<span class="src-comment">//</span>
<span class="src-comment">// The application model which generates load on the simulated LAN is</span>
<span class="src-comment">// simple yet powerful. It can be used as a rough model for any</span>
<span class="src-comment">// request-response based protocol such as SMB/CIFS (the Windows file</span>
<span class="src-comment">// sharing protocol), HTTP, or a database client-server protocol.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Every computer runs a client application (EtherAppCli) which connects</span>
<span class="src-comment">// to one of the servers. There's one server attached to switches A, B,</span>
<span class="src-comment">// C and D each: serverA, serverB, serverC and serverD -- server selection</span>
<span class="src-comment">// is configured in omnetpp.ini). The servers run EtherAppSrv.</span>
<span class="src-comment">// Clients periodically send a request to the server, and the request</span>
<span class="src-comment">// packet contains how many bytes the client wants the server to send back</span>
<span class="src-comment">// (this can mean one or more Ethernet frames, depending on the byte count).</span>
<span class="src-comment">//  Currently the request and reply lengths are configured in omnetpp.ini</span>
<span class="src-comment">// as intuniform(50,1400) and truncnormal(5000,5000).</span>
<span class="src-comment">//</span>
<span class="src-comment">// The volume of the traffic can most easily be controlled with the</span>
<span class="src-comment">// time period between sending requests; this is currently</span>
<span class="src-comment">// set in omnetpp.ini to exponential(0.50) (that is, average 2</span>
<span class="src-comment">// requests per second). This already causes frames to be dropped</span>
<span class="src-comment">// in some of the backbone switches, so the network is a bit</span>
<span class="src-comment">// overloaded with the current settings.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The model generates extensive statistics. All MACs (and most other</span>
<span class="src-comment">// modules too) write statistics into omnetpp.sca at the end</span>
<span class="src-comment">// of the simulation: number of frames sent, received, dropped, etc.</span>
<span class="src-comment">// These are only basic statistics, however it still makes the</span>
<span class="src-comment">// omnetpp.sca file to be about 28 Meg in size. You can use the Scalars</span>
<span class="src-comment">// program introduced in OMNeT++ 3.0a4 to analyse this file.</span>
<span class="src-comment">// (If the file size is too big, writing statistics can be disabled</span>
<span class="src-comment">// per module, with the "writeScalars" bool parameter. The model</span>
<span class="src-comment">// can also record output vectors (omnetpp.sca), but this is</span>
<span class="src-comment">// currently disabled in omnetpp.ini because the generated file</span>
<span class="src-comment">// can easily reach gigabyte sizes.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
</pre>
</body>
</html>
