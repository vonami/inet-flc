<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h2 class="comptitle">File <i>inet-doc.ned</i>
</h2>
<h3 class="subtitle">Contains:</h3>
<ul></ul>
<pre class="src"><span class="src-comment">//</span>
<span class="src-comment">// Copyright (C) 2000 Institut fuer Telematik, Universitaet Karlsruhe</span>
<span class="src-comment">//</span>
<span class="src-comment">// This program is free software; you can redistribute it and/or</span>
<span class="src-comment">// modify it under the terms of the GNU General Public License</span>
<span class="src-comment">// as published by the Free Software Foundation; either version 2</span>
<span class="src-comment">// of the License, or (at your option) any later version.</span>
<span class="src-comment">//</span>
<span class="src-comment">// This program is distributed in the hope that it will be useful,</span>
<span class="src-comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="src-comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="src-comment">// GNU General Public License for more details.</span>
<span class="src-comment">//</span>
<span class="src-comment">// You should have received a copy of the GNU General Public License</span>
<span class="src-comment">// along with this program; if not, write to the Free Software</span>
<span class="src-comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="src-comment">//</span>



<span class="src-comment">// @page inet-architecture.html, Architecture of the INET Framework</span>
<span class="src-comment">//</span>
<span class="src-comment">// The INET Framework builds upon OMNeT++, and uses the same concept:</span>
<span class="src-comment">// modules communicating by message passing.</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Modules and protocols&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// Protocols are represented by simple modules. A simple module's external</span>
<span class="src-comment">// interface (gates [connectors] and parameters) is described in a NED file,</span>
<span class="src-comment">// and the implementation is contained in a C++ class with the same name.</span>
<span class="src-comment">// Some examples: TCP, IP.</span>
<span class="src-comment">//</span>
<span class="src-comment">// These modules can be freely combined to form hosts and other network devices</span>
<span class="src-comment">// with the NED language (no C++ code and no recompilation required).</span>
<span class="src-comment">// Various pre-assembled host, router, switch, access point, etc. models can</span>
<span class="src-comment">// be found in the &lt;code&gt;Nodes/&lt;/code&gt; subdirectory (for example: StandardHost,</span>
<span class="src-comment">// Router), but you can also create your own ones for tailored to your particular</span>
<span class="src-comment">// simulation scenarios.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Network interfaces (Ethernet, 802.11, etc) are usually compound modules (i.e.</span>
<span class="src-comment">// assembled from simple modules) themselves, and are being composed of a queue,</span>
<span class="src-comment">// a MAC, and possibly other simple modules. See EthernetInterface as an example.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Not all modules implement protocols though. There are modules which hold</span>
<span class="src-comment">// data (for example RoutingTable), facilitate communication of modules</span>
<span class="src-comment">// (NotificationBoard), perform autoconfiguration of a network</span>
<span class="src-comment">// (FlatNetworkConfigurator), move a mobile node around (for example</span>
<span class="src-comment">// ConstSpeedMobility), and perform housekeeping associated with radio channels</span>
<span class="src-comment">// in wireless simulations (ChannelControl).</span>
<span class="src-comment">//</span>
<span class="src-comment">// Protocol headers and packet formats are described in message definition</span>
<span class="src-comment">// files (msg files), which are translated into C++ classes by OMNeT++'s</span>
<span class="src-comment">// &lt;i&gt;opp_msgc&lt;/i&gt; tool. The generated message classes subclass from OMNeT++'s</span>
<span class="src-comment">// &lt;code&gt;cMessage&lt;/code&gt; class.</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;About the documentation&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// The INET Framework documentation itself is also comprised of two bodies of HTML pages:</span>
<span class="src-comment">// &lt;i&gt;neddoc&lt;/i&gt; generated from NED and MSG files using OMNeT++'s &lt;i&gt;opp_neddoc&lt;/i&gt; tool,</span>
<span class="src-comment">// and the documentation of the underlying C++ classes, generated from the source files</span>
<span class="src-comment">// using Doxygen.</span>
<span class="src-comment">// The C++ doc is generated in a way that it contains &lt;b&gt;the full C++ source code&lt;/b&gt;</span>
<span class="src-comment">// as HTML pages. It is syntax highlighted, and variable and class names are hyperlinked</span>
<span class="src-comment">// and cross-referenced, which makes it convenient for exploring the code.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Common modules in hosts and routers&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// There are some common modules that appear in all (or many) host, router and device</span>
<span class="src-comment">// models.</span>
<span class="src-comment">//</span>
<span class="src-comment">// - InterfaceTable. This module contains the table of network interfaces</span>
<span class="src-comment">//   (eth0, wlan0, etc) in the host. This module does not send or receive messages:</span>
<span class="src-comment">//   it is accessed by other modules using standard C++ member function calls.</span>
<span class="src-comment">//   Other modules rely on the interface table submodule within the host to be called</span>
<span class="src-comment">//   &lt;code&gt;interfaceTable&lt;/code&gt; to be able to find it. (They obtain a &lt;code&gt;cModule *&lt;/code&gt;</span>
<span class="src-comment">//   pointer to it, then cast it to &lt;code&gt;\InterfaceTable *&lt;/code&gt; to be able to call its</span>
<span class="src-comment">//   functions). Network interfaces get dynamically registered (added to the table)</span>
<span class="src-comment">//   by simple modules implementing the network interface, for example EtherMAC.</span>
<span class="src-comment">//</span>
<span class="src-comment">// - RoutingTable. This module contains the \IP (v4) routing table, and heavily relies</span>
<span class="src-comment">//   on InterfaceTable for its operation. This module is also accessed from other</span>
<span class="src-comment">//   modules (typically IP) by calling the public member functions of its C++ class.</span>
<span class="src-comment">//   There are member functions for querying, adding, deleting routes, and</span>
<span class="src-comment">//   finding the best matching route for a given destination \IP address.</span>
<span class="src-comment">//   The routing table submodule within the host (router) must be called</span>
<span class="src-comment">//   &lt;code&gt;routingTable&lt;/code&gt; for other modules to find it.</span>
<span class="src-comment">//</span>
<span class="src-comment">// - RoutingTable6. This is like RoutingTable, but for IPv6.</span>
<span class="src-comment">//</span>
<span class="src-comment">// - NotificationBoard. This module makes it possible for several modules to</span>
<span class="src-comment">//   communicate in a publish-subscribe manner. For example, the radio module</span>
<span class="src-comment">//   (Ieee80211Radio) fires a &lt;i&gt;"radio state changed"&lt;/i&gt; notification when</span>
<span class="src-comment">//   the state of the radio channel changes (from TRANSMIT to IDLE, for example),</span>
<span class="src-comment">//   and it will be delivered to other modules that have previously subscribed</span>
<span class="src-comment">//   to that notification category. The notification mechanism also works</span>
<span class="src-comment">//   my C++ functions calls, no message sending is involved.</span>
<span class="src-comment">//   The notification board submodule within the host (router) must be called</span>
<span class="src-comment">//   &lt;code&gt;notificationBoard&lt;/code&gt; for other modules to find it.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Common modules at network level&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// Some modules have only one instance, at global network level:</span>
<span class="src-comment">//</span>
<span class="src-comment">// - FlatNetworkConfigurator assigns IP addresses to hosts and routers,</span>
<span class="src-comment">//   and sets up static routing.</span>
<span class="src-comment">//</span>
<span class="src-comment">// - ScenarioManager makes simulations scriptable. Modules can be made to support</span>
<span class="src-comment">//   scripting by implementing the &lt;code&gt;IScriptable&lt;/code&gt; C++ interface.</span>
<span class="src-comment">//</span>
<span class="src-comment">// - ChannelControl is required for wireless simulations. It keeps track of which</span>
<span class="src-comment">//   nodes are within interference distance of other nodes.</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;h3&gt;Communication between protocol layers&lt;/h3&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// In the INET Framework, when an upper-layer protocol wants to send a data</span>
<span class="src-comment">// packet over a lower-layer protocol, the upper-layer module just sends the</span>
<span class="src-comment">// message object representing the packet to the lower-layer module, which</span>
<span class="src-comment">// will in turn encapsulate it and send it. The reverse process takes place</span>
<span class="src-comment">// when a lower layer protocol receives a packet and sends it up after</span>
<span class="src-comment">// decapsulation.</span>
<span class="src-comment">//</span>
<span class="src-comment">// It is often necessary to convey extra information with the packet. For</span>
<span class="src-comment">// example, when an application-layer module wants to send data over TCP, some</span>
<span class="src-comment">// connection identifier needs to be specified for TCP. When TCP sends a</span>
<span class="src-comment">// segment over IP, IP will need a destination address and possibly other</span>
<span class="src-comment">// parameters like TTL. When IP sends a datagram to an Ethernet interface for</span>
<span class="src-comment">// transmission, a destination MAC address must be specified. This extra</span>
<span class="src-comment">// information is attached to the message object to as &lt;i&gt;control info&lt;/i&gt;.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Control info are small value objects, which are attached to packets</span>
<span class="src-comment">// (message objects) with its &lt;code&gt;setControlInfo()&lt;/code&gt; member function.</span>
<span class="src-comment">// Control info only holds auxiliary information for the next protocol layer,</span>
<span class="src-comment">// and is not supposed to be sent over the network to other hosts and routers.</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page ipaddresses.html, Specifying IP (IPv6) addresses in module parameters</span>
<span class="src-comment">//</span>
<span class="src-comment">// In INET, TCP, UDP and all application layer modules work with</span>
<span class="src-comment">// both IPv4 and IPv6. Internally they use the IPvXAddress C++ class, which</span>
<span class="src-comment">// can represent both IPv4 and IPv6 addresses.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Most modules use the IPAddressResolver C++ class to resolve addresses</span>
<span class="src-comment">// specified in module parameters in omnetpp.ini.</span>
<span class="src-comment">// IPAddressResolver accepts the following syntax:</span>
<span class="src-comment">//</span>
<span class="src-comment">//    - literal IPv4 address: "186.54.66.2"</span>
<span class="src-comment">//    - literal IPv6 address: "3011:7cd6:750b:5fd6:aba3:c231:e9f9:6a43"</span>
<span class="src-comment">//    - module name: "server", "subnet.server[3]"</span>
<span class="src-comment">//    - interface of a host or router: "server/eth0", "subnet.server[3]/eth0"</span>
<span class="src-comment">//    - IPv4 or IPv6 address of a host or router: "server(ipv4)",</span>
<span class="src-comment">//      "subnet.server[3](ipv6)"</span>
<span class="src-comment">//    - IPv4 or IPv6 address of an interface of a host or router:</span>
<span class="src-comment">//      "server/eth0(ipv4)", "subnet.server[3]/eth0(ipv6)"</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page irt.html, The IP routing files</span>
<span class="src-comment">//</span>
<span class="src-comment">// Routing files are files with &lt;tt&gt;.irt&lt;/tt&gt; or &lt;tt&gt;.mrt&lt;/tt&gt; extension,</span>
<span class="src-comment">// and their names are passed in the routingFileName parameter</span>
<span class="src-comment">// to RoutingTable modules. RoutingTables are present in all</span>
<span class="src-comment">// \IP nodes (hosts and routers).</span>
<span class="src-comment">//</span>
<span class="src-comment">// Routing files may contain network interface configuration and static</span>
<span class="src-comment">// routes. Both are optional. Network interface entries in the file</span>
<span class="src-comment">// configure existing interfaces; static routes are added to the route table.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Interfaces themselves are represented in the simulation by modules</span>
<span class="src-comment">// (such as the PPP module). Modules automatically register themselves</span>
<span class="src-comment">// with appropriate defaults in the RoutingTable, and entries in the</span>
<span class="src-comment">// routing file refine (overwrite) these settings.</span>
<span class="src-comment">// Interfaces are identified by names (e.g. ppp0, ppp1, eth0) which</span>
<span class="src-comment">// are normally derived from the module's name: a module called</span>
<span class="src-comment">// &lt;tt&gt;"ppp[2]"&lt;/tt&gt; in the NED file registers itself as interface ppp2.</span>
<span class="src-comment">//</span>
<span class="src-comment">// An example routing file (copied here from one of the example simulations):</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;pre&gt;</span>
<span class="src-comment">// ifconfig:</span>
<span class="src-comment">//</span>
<span class="src-comment">// # ethernet card 0 to router</span>
<span class="src-comment">// name: eth0   inet_addr: 172.0.0.3   MTU: 1500   Metric: 1  BROADCAST MULTICAST</span>
<span class="src-comment">// Groups: 225.0.0.1:225.0.1.2:225.0.2.1</span>
<span class="src-comment">//</span>
<span class="src-comment">// # Point to Point link 1 to Host 1</span>
<span class="src-comment">// name: ppp0   inet_addr: 172.0.0.4   MTU: 576   Metric: 1</span>
<span class="src-comment">//</span>
<span class="src-comment">// ifconfigend.</span>
<span class="src-comment">//</span>
<span class="src-comment">// route:</span>
<span class="src-comment">// 172.0.0.2   *           255.255.255.255  H  0   ppp0</span>
<span class="src-comment">// 172.0.0.4   *           255.255.255.255  H  0   ppp0</span>
<span class="src-comment">// default:    10.0.0.13   0.0.0.0          G  0   eth0</span>
<span class="src-comment">//</span>
<span class="src-comment">// 225.0.0.1   *           255.255.255.255  H  0   ppp0</span>
<span class="src-comment">// 225.0.1.2   *           255.255.255.255  H  0   ppp0</span>
<span class="src-comment">// 225.0.2.1   *           255.255.255.255  H  0   ppp0</span>
<span class="src-comment">//</span>
<span class="src-comment">// 225.0.0.0   10.0.0.13   255.0.0.0        G  0   eth0</span>
<span class="src-comment">//</span>
<span class="src-comment">// routeend.</span>
<span class="src-comment">// &lt;/pre&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// The &lt;tt&gt;ifconfig...ifconfigend.&lt;/tt&gt; part configures interfaces,</span>
<span class="src-comment">// and &lt;tt&gt;route..routeend.&lt;/tt&gt; part contains static routes.</span>
<span class="src-comment">// The format of these sections roughly corresponds to the output</span>
<span class="src-comment">// of the &lt;tt&gt;ifconfig&lt;/tt&gt; and &lt;tt&gt;netstat -rn&lt;/tt&gt; Unix commands.</span>
<span class="src-comment">//</span>
<span class="src-comment">// An interface entry begins with a &lt;tt&gt;name:&lt;/tt&gt; field, and lasts until</span>
<span class="src-comment">// the next &lt;tt&gt;name:&lt;/tt&gt; (or until &lt;tt&gt;ifconfigend.&lt;/tt&gt;). It may</span>
<span class="src-comment">// be broken into several lines.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Accepted interface fields are:</span>
<span class="src-comment">//    - &lt;tt&gt;name:&lt;/tt&gt; - arbitrary interface name (e.g. eth0, ppp0)</span>
<span class="src-comment">//    - &lt;tt&gt;inet_addr:&lt;/tt&gt; - \IP address</span>
<span class="src-comment">//    - &lt;tt&gt;Mask:&lt;/tt&gt; - netmask</span>
<span class="src-comment">//    - &lt;tt&gt;Groups:&lt;/tt&gt; Multicast groups. 224.0.0.1 is added automatically,</span>
<span class="src-comment">//      and 224.0.0.2 also if the node is a router (IPForward==true).</span>
<span class="src-comment">//    - &lt;tt&gt;MTU:&lt;/tt&gt; - MTU on the link (e.g. Ethernet: 1500)</span>
<span class="src-comment">//    - &lt;tt&gt;Metric:&lt;/tt&gt; - integer route metric</span>
<span class="src-comment">//    - flags: &lt;tt&gt;BROADCAST&lt;/tt&gt;, &lt;tt&gt;MULTICAST&lt;/tt&gt;, &lt;tt&gt;POINTTOPOINT&lt;/tt&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// The following fields are parsed but ignored: &lt;tt&gt;Bcast&lt;/tt&gt;,&lt;tt&gt;encap&lt;/tt&gt;,</span>
<span class="src-comment">// &lt;tt&gt;HWaddr&lt;/tt&gt;.</span>
<span class="src-comment">//</span>
<span class="src-comment">// Interface modules set a good default for MTU, Metric (as 2e9/bitrate) and</span>
<span class="src-comment">// flags, but leave inet_addr and Mask empty. inet_addr and mask should</span>
<span class="src-comment">// be set either from the routing file or by a dynamic network configuration</span>
<span class="src-comment">// module.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The route fields are:</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;pre&gt;</span>
<span class="src-comment">// Destination  Gateway  Netmask  Flags  Metric Interface</span>
<span class="src-comment">// &lt;/pre&gt;</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;i&gt;Destination, Gateway&lt;/i&gt; and &lt;i&gt;Netmask&lt;/i&gt; have the usual meaning.</span>
<span class="src-comment">// The &lt;i&gt;Destination&lt;/i&gt; field should either be an \IP address or "default:"</span>
<span class="src-comment">// (to designate the default route). For &lt;i&gt;Gateway&lt;/i&gt;, &lt;tt&gt;*&lt;/tt&gt; is also</span>
<span class="src-comment">// accepted with the meaning &lt;tt&gt;0.0.0.0&lt;/tt&gt;.</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;i&gt;Flags&lt;/i&gt; denotes route type:</span>
<span class="src-comment">//    - &lt;i&gt;H&lt;/i&gt; "host": direct route (directly attached to the router), and</span>
<span class="src-comment">//    - &lt;i&gt;G&lt;/i&gt; "gateway": remote route (reached through another router)</span>
<span class="src-comment">//</span>
<span class="src-comment">// &lt;i&gt;Interface&lt;/i&gt; is the interface name, e.g. &lt;tt&gt;eth0&lt;/tt&gt;.</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">//</span>
<span class="src-comment">// @page ipv6overview.html, IPv6 model overview</span>
<span class="src-comment">//</span>
<span class="src-comment">// \IPv6 support is implemented by several cooperating modules. The IPv6 module</span>
<span class="src-comment">// implements \IPv6 datagram handling (sending, forwarding etc). It relies on</span>
<span class="src-comment">// RoutingTable6 to get access to the routes. RoutingTable6 also contains the</span>
<span class="src-comment">// neighbour discovery data structures (destination cache, neighbour cache,</span>
<span class="src-comment">// prefix list -- the latter effectively merged into the route table). Interface</span>
<span class="src-comment">// configuration (address, state, timeouts etc) is held in the InterfaceTable,</span>
<span class="src-comment">// in &lt;tt&gt;IPv6InterfaceData&lt;/tt&gt; objects attached to &lt;tt&gt;InterfaceEntry&lt;/tt&gt;</span>
<span class="src-comment">// as its &lt;tt&gt;ipv6()&lt;/tt&gt; member.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The module IPv6NeighbourDiscovery implements all tasks associated with</span>
<span class="src-comment">// neighbour discovery and stateless address autoconfiguration. The data</span>
<span class="src-comment">// structures themselves (destination cache, neighbour cache, prefix list)</span>
<span class="src-comment">// are kept in RoutingTable6, and are accessed via public C++ methods.</span>
<span class="src-comment">// Neighbour discovery packets are only sent and processed by this module --</span>
<span class="src-comment">// when IPv6 receives one, it forwards the packet to IPv6NeighbourDiscovery.</span>
<span class="src-comment">//</span>
<span class="src-comment">// The rest of \ICMPv6 (\ICMP errors, echo request/reply etc) is implemented in</span>
<span class="src-comment">// the module ICMPv6, just like with \IPv4. \ICMP errors are sent into</span>
<span class="src-comment">// IPv6ErrorHandling, which the user can extend or replace to get errors</span>
<span class="src-comment">// handled in any way they like.</span>
<span class="src-comment">//</span>
</pre>
</body>
</html>
