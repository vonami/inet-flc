<?xml version="1.0"?>
<neddoc-tags>
  <tag type="class" name="IPControlInfo" htmlfile="IPControlInfo-id228197.html" nedfile="Network/Contract/IPControlInfo.msg" comment="//&#10;// Control information for sending/receiving packets over \IP.&#10;//&#10;// To send a packet over \IP, fill in an IPControlInfo object,&#10;// attach it to the packet with the C++ method setControlInfo(),&#10;// the send it to the IP module.&#10;//&#10;// When IP delivers packets to higher layers, it also attaches&#10;// similar IPControlInfo objects to them.&#10;//&#10;// When sending, the following fields are required:&#10;// - protocol: a value from IPProtocolId&#10;// - destAddr&#10;//&#10;// Optional fields:&#10;// - srcAddr: it will be set to the address of the outgoing interface&#10;// - diffServCodePoint: used in DS_Field (RFC 2474) instead of TOS (default: 0)&#10;// - timeToLive: default defined as module parameter&#10;// - dontFragment: default: false&#10;//&#10;// Not supported:&#10;// - options: \IP Options currently not used&#10;// - Identifier is currently always chosen by the \IP layer&#10;//&#10;"/>
  <tag type="class" name="IPRecordRouteOption" htmlfile="IPRecordRouteOption-id231647.html" nedfile="Network/IPv4/IPDatagram.msg" comment="//&#10;// Option structure: Record Route&#10;//&#10;"/>
  <tag type="class" name="IPRoutingDecision" htmlfile="IPRoutingDecision-id228218.html" nedfile="Network/Contract/IPControlInfo.msg" comment="//&#10;// Control info attached to packets sent from IP to ARP.&#10;//&#10;// Next hop address is used on a LAN to determine the MAC destination&#10;// address (and it may be used on other multicast networks for similar&#10;// addressing purpose).&#10;//&#10;"/>
  <tag type="class" name="IPSourceRoutingOption" htmlfile="IPSourceRoutingOption-id231760.html" nedfile="Network/IPv4/IPDatagram.msg" comment="//&#10;// Option Structure: Source Routing&#10;//&#10;"/>
  <tag type="class" name="IPTimestampOption" htmlfile="IPTimestampOption-id231686.html" nedfile="Network/IPv4/IPDatagram.msg" comment="//&#10;// Option structure: Timestamp&#10;//&#10;"/>
  <tag type="class" name="IPv6AuthenticationHeader" htmlfile="IPv6AuthenticationHeader-id233072.html" nedfile="Network/IPv6/IPv6ExtensionHeaders.msg" comment="//&#10;// Authentication Header&#10;// RFC 2402&#10;// Not Implemented&#10;//&#10;"/>
  <tag type="class" name="IPv6ControlInfo" htmlfile="IPv6ControlInfo-id228808.html" nedfile="Network/Contract/IPv6ControlInfo.msg" comment="//&#10;// Control information for sending/receiving packets over \IPv6.&#10;//&#10;// To send a packet over \IPv6, fill in an IPv6ControlInfo object,&#10;// attach it to the packet with the C++ method setControlInfo(),&#10;// the send it to the IPv6 module.&#10;//&#10;// When IPv6 delivers packets to higher layers, it also attaches&#10;// similar IPv6ControlInfo objects to them.&#10;//&#10;// When sending, the following fields are required:&#10;// - protocol: a value from IPProtocolId&#10;// - destAddr&#10;//&#10;// Optional fields:&#10;// - srcAddr: it will be set to the address of the outgoing interface&#10;// - timeToLive&#10;//&#10;"/>
  <tag type="class" name="IPv6DestinationOptionsHeader" htmlfile="IPv6DestinationOptionsHeader-id233039.html" nedfile="Network/IPv6/IPv6ExtensionHeaders.msg" comment="//&#10;// Destination Options Header&#10;// RFC 2460 Section 4.6&#10;// Next Header Value: 60&#10;//&#10;"/>
  <tag type="class" name="IPv6EncapsulatingSecurityPayloadHeader" htmlfile="IPv6EncapsulatingSecurityPayloadHeader-id233103.html" nedfile="Network/IPv6/IPv6ExtensionHeaders.msg" comment="//&#10;// Encapsulating Security Payload Header&#10;// RFC 2406&#10;// Not Implemented&#10;//&#10;"/>
  <tag type="class" name="IPv6ExtensionHeader" htmlfile="IPv6ExtensionHeader-id232757.html" nedfile="Network/IPv6/IPv6Datagram.msg" comment="//&#10;// This serves as the base class for all the other extension headers.&#10;//&#10;"/>
  <tag type="class" name="IPv6FragmentHeader" htmlfile="IPv6FragmentHeader-id232854.html" nedfile="Network/IPv6/IPv6ExtensionHeaders.msg" comment="//&#10;// Fragment Header&#10;// RFC 2460 Section 4.5&#10;// Next Header Value: 44&#10;//&#10;"/>
  <tag type="class" name="IPv6HopByHopOptionsHeader" htmlfile="IPv6HopByHopOptionsHeader-id232963.html" nedfile="Network/IPv6/IPv6ExtensionHeaders.msg" comment="//&#10;// Hop-by-Hop Options Header.&#10;// RFC 2460 Section 4.3&#10;// Next Header Value: 0&#10;//&#10;"/>
  <tag type="class" name="IPv6NDPrefixInformation" htmlfile="IPv6NDPrefixInformation-id230079.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// IPv6ND Prefix Information&#10;// RFC 2461 Section 4.6.2&#10;//&#10;"/>
  <tag type="class" name="IPv6RoutingHeader" htmlfile="IPv6RoutingHeader-id232795.html" nedfile="Network/IPv6/IPv6ExtensionHeaders.msg" comment="//&#10;// Routing Header&#10;// RFC 2460 Section 4.4&#10;// Next Header Value: 43&#10;//&#10;"/>
  <tag type="class" name="Ieee80211AssociationRequestFrameBody" htmlfile="Ieee80211AssociationRequestFrameBody-id248464.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Association request frame body format&#10;//&#10;"/>
  <tag type="class" name="Ieee80211AssociationResponseFrameBody" htmlfile="Ieee80211AssociationResponseFrameBody-id248556.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Association response frame body format&#10;//&#10;"/>
  <tag type="class" name="Ieee80211AuthenticationFrameBody" htmlfile="Ieee80211AuthenticationFrameBody-id248265.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Authentication frame body format.&#10;//&#10;// Note: the &quot;isLast&quot; field is not part of the standard.&#10;// The authentication procedure is simulated by this model by exchanging&#10;// a number of &quot;dummy&quot; authentication frames without real contents;&#10;// the &quot;isLast&quot; field gets set by the AP to signal the STA that&#10;// the authentication procedure has completed and it does not need to&#10;// send any more Authentication frames.&#10;//&#10;"/>
  <tag type="class" name="Ieee80211BeaconFrameBody" htmlfile="Ieee80211BeaconFrameBody-id248635.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Beacon frame body format.&#10;//&#10;"/>
  <tag type="class" name="Ieee80211DeauthenticationFrameBody" htmlfile="Ieee80211DeauthenticationFrameBody-id248334.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// De-authentication frame body format&#10;//&#10;"/>
  <tag type="class" name="Ieee80211DisassociationFrameBody" htmlfile="Ieee80211DisassociationFrameBody-id248374.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Dis-association frame body format (same as De-authentication)&#10;//&#10;"/>
  <tag type="class" name="Ieee80211FrameBody" htmlfile="Ieee80211FrameBody-id248235.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Frame body base class used to hide various frame body types&#10;//&#10;"/>
  <tag type="class" name="Ieee80211PrimConfirm" htmlfile="Ieee80211PrimConfirm-id249606.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Base class for confirm primitives&#10;//&#10;"/>
  <tag type="class" name="Ieee80211PrimRequest" htmlfile="Ieee80211PrimRequest-id249593.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Base class for request primitives&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_AssociateConfirm" htmlfile="Ieee80211Prim_AssociateConfirm-id250013.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-ASSOCIATE.confirm&#10;// Possible result codes: SUCCESS, INVALID_PARAMETERS, TIMEOUT, REFUSED&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_AssociateRequest" htmlfile="Ieee80211Prim_AssociateRequest-id249976.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-ASSOCIATE.request&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_AuthenticateConfirm" htmlfile="Ieee80211Prim_AuthenticateConfirm-id249898.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-AUTHENTICATE.confirm.&#10;// Possible result codes: SUCCESS, INVALID_PARAMETERS, TIMEOUT, TOO_MANY_SIMULTANEOUS_REQUESTS, REFUSED&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_AuthenticateRequest" htmlfile="Ieee80211Prim_AuthenticateRequest-id249856.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-AUTHENTICATE.request.&#10;//&#10;// Note: the &quot;authType&quot; parameter (Open System, Shared Key, etc) is omitted.&#10;// The authentication procedure is simulated by this model by exchanging&#10;// a number of &quot;dummy&quot; authentication frames without real contents,&#10;// and it is configured in the AP how many authentication steps it requires.&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_BSSDescription" htmlfile="Ieee80211Prim_BSSDescription-id249755.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment=""/>
  <tag type="class" name="Ieee80211Prim_DeauthenticateRequest" htmlfile="Ieee80211Prim_DeauthenticateRequest-id249930.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-DEAUTHENTICATE.request&#10;//&#10;// NOTE: there is no Deauthenticate Confirm, because Deauthenticate Request &#10;// takes place immediately, and nothing can go wrong (there is no reply &#10;// from the AP to wait for)&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_DisassociateRequest" htmlfile="Ieee80211Prim_DisassociateRequest-id250069.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-DISASSOCIATE.request.&#10;//&#10;// NOTE: there is no Disassociate Confirm, because Disassociate Request &#10;// takes place immediately, and nothing can go wrong (there is no reply &#10;// from the AP to wait for)&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_ReassociateConfirm" htmlfile="Ieee80211Prim_ReassociateConfirm-id250051.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// MLME-REASSOCIATE.confirm is very similar to MLME-ASSOCIATE.confirm&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_ReassociateRequest" htmlfile="Ieee80211Prim_ReassociateRequest-id250033.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// MLME-REASSOCIATE.request is very similar to MLME-ASSOCIATE.request&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_ScanConfirm" htmlfile="Ieee80211Prim_ScanConfirm-id249824.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-SCAN.confirm&#10;// Possible result codes: SUCCESS, INVALID_PARAMETERS&#10;//&#10;"/>
  <tag type="class" name="Ieee80211Prim_ScanRequest" htmlfile="Ieee80211Prim_ScanRequest-id249633.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Losely based on MLME-SCAN.request.&#10;//&#10;"/>
  <tag type="class" name="Ieee80211ProbeRequestFrameBody" htmlfile="Ieee80211ProbeRequestFrameBody-id248415.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Probe request frame body format&#10;//&#10;"/>
  <tag type="class" name="Ieee80211ProbeResponseFrameBody" htmlfile="Ieee80211ProbeResponseFrameBody-id248710.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Probe response frame body format (same as Beacon)&#10;//&#10;"/>
  <tag type="class" name="Ieee80211ReassociationRequestFrameBody" htmlfile="Ieee80211ReassociationRequestFrameBody-id248513.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Re-association request frame body format (same as association)&#10;//&#10;"/>
  <tag type="class" name="Ieee80211ReassociationResponseFrameBody" htmlfile="Ieee80211ReassociationResponseFrameBody-id248616.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Re-association response frame body format (same as AssociationResponse)&#10;//&#10;"/>
  <tag type="class" name="Ieee802Ctrl" htmlfile="Ieee802Ctrl-id239221.html" nedfile="NetworkInterfaces/Contract/Ieee802Ctrl.msg" comment="//&#10;// Control structure for communication between LLC and higher layers&#10;//&#10;"/>
  <tag type="class" name="Link" htmlfile="Link-id234797.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//class Link extends cObject&#10;"/>
  <tag type="class" name="OSPFASExternalLSA" htmlfile="OSPFASExternalLSA-id235164.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF AS External LSA&#10;//&#10;"/>
  <tag type="class" name="OSPFASExternalLSAContents" htmlfile="OSPFASExternalLSAContents-id235086.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents the contents of an OSPF AS External LSA&#10;//&#10;"/>
  <tag type="class" name="OSPFLSA" htmlfile="OSPFLSA-id234690.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// common ancestor type for all LSAs&#10;//&#10;//class OSPFLSA extends cObject&#10;"/>
  <tag type="class" name="OSPFLSAHeader" htmlfile="OSPFLSAHeader-id234593.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF LSA header&#10;//&#10;//class OSPFLSAHeader extends cObject&#10;"/>
  <tag type="class" name="OSPFNetworkLSA" htmlfile="OSPFNetworkLSA-id234948.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Network LSA&#10;//&#10;"/>
  <tag type="class" name="OSPFRouterLSA" htmlfile="OSPFRouterLSA-id234875.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Router LSA&#10;//&#10;"/>
  <tag type="class" name="OSPFSummaryLSA" htmlfile="OSPFSummaryLSA-id234988.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Summary LSA&#10;//&#10;"/>
  <tag type="class" name="PhyControlInfo" htmlfile="PhyControlInfo-id239333.html" nedfile="NetworkInterfaces/Contract/PhyControlInfo.msg" comment="//&#10;// Control info for controlling the physical layer (the radio).&#10;//&#10;"/>
  <tag type="class" name="SnrControlInfo" htmlfile="SnrControlInfo-id252996.html" nedfile="NetworkInterfaces/MFCore/SnrControlInfo.msg" comment="//&#10;// Control Info class that is used to send SNR information from&#10;// snrEval to decider&#10;//&#10;// This class is used by the snrEval to send SNR information&#10;// to the decider. After recieving a packet from the channel the&#10;// snrEval calculates SNR information, writes this into the SnrControlInfo&#10;// and attaches the ControlInfo to the Airframe.&#10;//&#10;// This control info can be used for complex information,&#10;// i.e. different SNR levels over the transmission time of this&#10;// packet. The parameter snrList is a dynamic list (see&#10;// http://www.sgi.com/tech/stl/List.html). The list entries are&#10;// defined by the struct SnrListEntry, which only contains two&#10;// parameters of type double, time and SNR. These values are a certain&#10;// SNR level and the time at which this SNR level started. The thing&#10;// is that you can't manipulate the list directly in the class.&#10;// Instead you have to create your own list with 'SnrList&#10;// listName;'. Furthermore you have to create a new object of the struct&#10;// SnrListEntry everytime you add something to the list.&#10;//&#10;// So, every list entry should look something like this:&#10;//&#10;// SnrListEntry listEntry;&lt;br&gt;&#10;// listEntry.time = snrStartingTime;&lt;br&gt;&#10;// listEntry.snr  = snrLevel;&lt;br&gt;&#10;// listName.push_back( listEntry );&#10;//&#10;// When the list is complete and you want to send the message, you&#10;// have to give the list to the control info  before attaching it to&#10;// the AirFrame.&#10;//&#10;// SnrControlInfo* cInfo = new SnrControlInfo;&lt;br&gt;&#10;// cInfo-&gt;setSnrList( listName );&lt;br&gt;&#10;// msg-&gt;setControlInfo( cInfo );&#10;//&#10;// When receiving an AirFrame (in the deceider module) you probably want to&#10;// read the list. Therefore you have to get a copy of that list:&#10;//&#10;// SnrControlInfo* cInfo = new SnrControlInfo;&lt;br&gt;&#10;// cInfo = static_cast&lt;SnrControlInfo*&gt;(msg-&gt;removeControlInfo());&lt;br&gt;&#10;// SnrList receivedList* = new SnrList;&lt;br&gt;&#10;// receivedList = cInfo-&gt;getSnrList();&lt;br&gt;&#10;// delete cInfo;&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @author Marc Loebbers&#10;//&#10;"/>
  <tag type="class" name="TCPCommand" htmlfile="TCPCommand-id268543.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Control info for \TCP connections. This class is to be set as control info&#10;// (see cMessage::setControlInfo()) on all messages exchanged between TCP and&#10;// application, in both directions. Some commands and indications&#10;// (TCP_C_OPEN_xxx, TCP_I_STATUS) use subclasses.&#10;//&#10;// connId identifies the connection locally within the application (internally,&#10;// TCP uses the (app gate index, connId) pair to identify the socket).&#10;// connId is to be chosen by the application in the open command.&#10;//&#10;//# TODO explain userId&#10;//&#10;// @see TcpCommandCode, TcpStatusInd, TCPOpenCommand, TCPStatusInfo, TCP&#10;//&#10;"/>
  <tag type="class" name="TCPConnectInfo" htmlfile="TCPConnectInfo-id268949.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Sent with message kind TCP_I_ESTABLISHED, to let the app know&#10;// about the local and remote IP address and port.&#10;//&#10;// @see TcpCommandCode, TCP&#10;//&#10;"/>
  <tag type="class" name="TCPErrorInfo" htmlfile="TCPErrorInfo-id268608.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Currently not in use.&#10;//&#10;"/>
  <tag type="class" name="TCPOpenCommand" htmlfile="TCPOpenCommand-id268798.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Control info to be used for active or passive TCP open.&#10;//&#10;// localAddr, remoteAddr, localPort, remotePort should be self-explanatory.&#10;// localAddr is optional because TCP can learn it from IP when a packet&#10;// is received from the peer; localPort is optional because TCP supports&#10;// ephemeral ports.&#10;//&#10;// The sendQueueClass, receiveQueueClass and tcpAlgorithmClass fields&#10;// allow per-connection TCP configuration. These fields may contain&#10;// names of classes subclassed from TCPSendQueue, TCPReceiveQueue&#10;// and TCPAlgorithm, respectively. If not set, module parameters with&#10;// similar names are used.&#10;//&#10;// The fork parameter is used with passive open, and controls what happens&#10;// when an incoming connection is received. With fork=true, it emulates&#10;// the Unix accept(2) syscall semantics: a new connection structure&#10;// is created for the connection (with a new connId, see in TCPCommand),&#10;// and the connection structure with the old connId remains listening.&#10;// With fork=false, all the above does not happen: the first connection&#10;// is accepted (with the original connId), and further incoming connections&#10;// will be refused by TCP by sending an RST segment.&#10;//&#10;// @see TcpCommandCode, TCP&#10;//&#10;"/>
  <tag type="class" name="TCPSendCommand" htmlfile="TCPSendCommand-id268919.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Control info to be used with the SEND command.&#10;//&#10;// @see TcpCommandCode, TCP&#10;//&#10;"/>
  <tag type="class" name="TCPStatusInfo" htmlfile="TCPStatusInfo-id269015.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Sent with message kind TCP_I_STATUS, in response to command TCP_C_STATUS.&#10;// For explanation of variables, see RFC 793 or TCPStateVariables in&#10;// TCPConnection.h.&#10;//&#10;// @see TcpStatusInd, TcpCommandCode, TCP&#10;//&#10;"/>
  <tag type="class" name="TEDChangeInfo" htmlfile="TEDChangeInfo-id238851.html" nedfile="Network/TED/TED.msg" comment="//&#10;// Data structure supplied with NF_TED_CHANGE NotificationBoard notifications.&#10;// This triggers the link state protocol to send out up-to-date link state info&#10;// about the given links.&#10;//&#10;"/>
  <tag type="class" name="UDPControlInfo" htmlfile="UDPControlInfo-id269416.html" nedfile="Transport/Contract/UDPControlInfo.msg" comment="//&#10;// Control info for sending/receiving data via \UDP. Travels between&#10;// application and the UDP module.&#10;//&#10;// The most convenient way to handle UDP is the UDPSocket class, which hides&#10;// UDPControlInfo completely from you. But even if you manage talking&#10;// to UDP yourself without help from UDPSocket, sockId must be obtained&#10;// from UDPSocket::generateSocketId().&#10;//&#10;//# TODO explain userId, sockId, etc.&#10;//&#10;// @see UDPCommandCode&#10;//&#10;"/>
  <tag type="compound-module" name="BasicMobility" htmlfile="BasicMobility-id225842.html" nedfile="Mobility/BasicMobility.ned" comment="//&#10;// This is not an actual mobility model, but a prototype for other mobility models.&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="compound-module" name="BurstHost" htmlfile="BurstHost-id256128.html" nedfile="Nodes/INET/BurstHost.ned" comment="//&#10;// Definition of an IP node with a transport generator that connects&#10;// to IP directly, without TCP or UDP.&#10;//&#10;"/>
  <tag type="compound-module" name="EtherSwitch" htmlfile="EtherSwitch-id242754.html" nedfile="NetworkInterfaces/EtherSwitch/EtherSwitch.ned" comment="//&#10;// Model of an Ethernet switch.&#10;//&#10;// The duplexChannel attributes of the MACs must be set according to the&#10;// medium connected to the port; if collisions are possible (it's a bus or hub)&#10;// it must be set to false, otherwise it can be set to true.&#10;//&#10;// This model does not contain the spanning tree algorithm.&#10;//&#10;"/>
  <tag type="compound-module" name="EtherSwitch2" htmlfile="EtherSwitch2-id243162.html" nedfile="NetworkInterfaces/EtherSwitch/EtherSwitch2.ned" comment="//&#10;// Model of an Ethernet switch built with EtherMAC2, which means&#10;// that all ports are operating in strictly full-duplex mode.&#10;// Use EtherSwitch if you need half-duplex operation on some ports.&#10;//&#10;// This model does not contain the spanning tree algorithm.&#10;//&#10;"/>
  <tag type="compound-module" name="EthernetInterface" htmlfile="EthernetInterface-id241239.html" nedfile="NetworkInterfaces/Ethernet/EthernetInterface.ned" comment="//&#10;// Ethernet network interface. Corresponds to the prototype NetworkInterface.&#10;// Complements EtherMAC and EtherEncap with an output queue for QoS and&#10;// RED support.&#10;//&#10;// @see EthernetInterface2, EthernetInterfaceNoQueue&#10;//&#10;"/>
  <tag type="compound-module" name="EthernetInterface2" htmlfile="EthernetInterface2-id241696.html" nedfile="NetworkInterfaces/Ethernet/EthernetInterface2.ned" comment="//&#10;// Ethernet network interface, which supports full-duplex operation only.&#10;// Corresponds to the prototype NetworkInterface.&#10;// Complements EtherMAC2 and EtherEncap with an output queue for QoS and&#10;// RED support.&#10;//&#10;// @see EthernetInterface, EthernetInterfaceNoQueue&#10;//&#10;"/>
  <tag type="compound-module" name="EthernetInterfaceNoQueue" htmlfile="EthernetInterfaceNoQueue-id242071.html" nedfile="NetworkInterfaces/Ethernet/EthernetInterfaceNoQueue.ned" comment="//&#10;// Ethernet network interface. Assumes inifinite queue.&#10;//&#10;// @see EthernetInterface&#10;//&#10;"/>
  <tag type="compound-module" name="FailedRouter" htmlfile="FailedRouter-id256530.html" nedfile="Nodes/INET/FailedRouter.ned" comment="//&#10;// A failed \IP router. Simply discards all packets it receives, and that's all.&#10;//&#10;"/>
  <tag type="compound-module" name="IGMP" htmlfile="IGMP-id230741.html" nedfile="Network/IPv4/IGMP.ned" comment="//&#10;// Placeholder for the IGMP protocol&#10;//&#10;// author: Andras Varga&#10;//&#10;"/>
  <tag type="compound-module" name="Ieee80211Nic" htmlfile="Ieee80211Nic-id244350.html" nedfile="NetworkInterfaces/Ieee80211/Ieee80211Nic.ned" comment="//&#10;// This NIC implements an 802.11 network interface card.&#10;// It can be configured via the mgmtType parameter to act&#10;// as an AP or a STA, or for ad-hoc mode.&#10;//&#10;"/>
  <tag type="compound-module" name="Ieee80211NicAP" htmlfile="Ieee80211NicAP-id244686.html" nedfile="NetworkInterfaces/Ieee80211/Ieee80211NicAP.ned" comment="//&#10;// This NIC implements an 802.11 network interface card,&#10;// in an AP, using infrastructure mode.&#10;//&#10;"/>
  <tag type="compound-module" name="Ieee80211NicAPSimplified" htmlfile="Ieee80211NicAPSimplified-id245071.html" nedfile="NetworkInterfaces/Ieee80211/Ieee80211NicAPSimplified.ned" comment="//&#10;// This NIC implements an infrastructure mode 802.11 network interface card&#10;// for a wireless Access Point (AP), but using a simplified mgmt module&#10;// that does not support handovers.&#10;//&#10;"/>
  <tag type="compound-module" name="Ieee80211NicAdhoc" htmlfile="Ieee80211NicAdhoc-id244189.html" nedfile="NetworkInterfaces/Ieee80211/Ieee80211NicAdhoc.ned" comment="//&#10;// This NIC implements an 802.11 network interface card in ad-hoc mode.&#10;//&#10;"/>
  <tag type="compound-module" name="Ieee80211NicSTA" htmlfile="Ieee80211NicSTA-id245326.html" nedfile="NetworkInterfaces/Ieee80211/Ieee80211NicSTA.ned" comment="//&#10;// This NIC implements an 802.11 network interface card,&#10;// in a STA, using infrastructure mode.&#10;//&#10;"/>
  <tag type="compound-module" name="Ieee80211NicSTASimplified" htmlfile="Ieee80211NicSTASimplified-id245578.html" nedfile="NetworkInterfaces/Ieee80211/Ieee80211NicSTASimplified.ned" comment="//&#10;// This NIC implements an infrastructure mode 802.11 network interface card&#10;// for a host (STA), but using a simplified mgmt module that does not&#10;// support handovers.&#10;//&#10;"/>
  <tag type="compound-module" name="LDP_FAILED" htmlfile="LDP_FAILED-id262980.html" nedfile="Nodes/MPLS/LDP_FAILED.ned" comment="//&#10;// Failed router. Discards all incoming traffic and generates nothing. Its&#10;// interface (gates, parameters) is fully compatible with the RSVP_LSR router&#10;// and node failures may thus be simulated by replacing the RSVP_LSR&#10;// with \FAILED_LSR.&#10;//&#10;"/>
  <tag type="compound-module" name="LDP_LSR" htmlfile="LDP_LSR-id263362.html" nedfile="Nodes/MPLS/LDP_LSR.ned" comment="//&#10;// An LDP-capable router.&#10;//&#10;// LDP Capable Routers are main building blocks for an LDP MPLS network.&#10;//&#10;"/>
  <tag type="compound-module" name="MFMobileHost" htmlfile="MFMobileHost-id254785.html" nedfile="Nodes/Adhoc/MFMobileHost.ned" comment="//&#10;// Models a mobile host with a wireless (802.11b) card in ad-hoc mode.&#10;// This model contains the Mobility Framework's 802.11 implementation, Nic80211,&#10;// and IP, TCP and UDP protocols. The mobility model can be dynamically&#10;// specified with the mobilityType parameter.&#10;//&#10;// @see MobileHost, WirelessHost&#10;//&#10;"/>
  <tag type="compound-module" name="MobileHost" htmlfile="MobileHost-id255482.html" nedfile="Nodes/Adhoc/MobileHost.ned" comment="//&#10;// Models a mobile host with a wireless (802.11b) card in ad-hoc mode.&#10;// This model contains the new IEEE 802.11 implementation, Ieee80211Nic,&#10;// and IP, TCP and UDP protocols. The mobility model can be&#10;// dynamically specified with the mobilityType parameter.&#10;//&#10;// @see MFMobileHost, WirelessHost&#10;//&#10;"/>
  <tag type="compound-module" name="NetworkInterface" htmlfile="NetworkInterface-id238963.html" nedfile="NetworkInterfaces/NetworkInterface.ned" comment="//&#10;// Prototype module for link layer protocols.&#10;//&#10;"/>
  <tag type="compound-module" name="NetworkLayer" htmlfile="NetworkLayer-id256856.html" nedfile="Nodes/INET/NetworkLayer.ned" comment="//&#10;// Network layer of an \IP node.&#10;//&#10;// Interfaces to transport layer: TCP, UDP, echo/ping, RSVP&#10;//&#10;"/>
  <tag type="compound-module" name="NetworkLayer6" htmlfile="NetworkLayer6-id261162.html" nedfile="Nodes/IPv6/NetworkLayer6.ned" comment="//&#10;// Represents an IPv6 network layer (L3).&#10;//&#10;// The module has ports to connect to a higher layer (TCP,UDP) and&#10;// several network interfaces.&#10;//&#10;"/>
  <tag type="compound-module" name="Nic80211" htmlfile="Nic80211-id250122.html" nedfile="NetworkInterfaces/MF80211/Nic80211.ned" comment="//&#10;// This NIC implements an 802.11 network interface card.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @see Mac80211, Decider80211, SnrEval80211&#10;// @author Marc Loebbers&#10;//&#10;"/>
  <tag type="compound-module" name="NicCsma" htmlfile="NicCsma-id250564.html" nedfile="NetworkInterfaces/MF80211/NicCsma.ned" comment="//&#10;// The CsmaNic contains a csma-like MAC layer.&#10;// The SnrEval module is used as the mac needs a RadioState to be published.&#10;// However as still the BasicDecider is used all messages will be delivered to&#10;// the MAC and no packets get lost&#10;//&#10;// This nic is intended to be used in order to test the implementation&#10;// of the csma protocol.&#10;//&#10;// IMPORTANT:&lt;br&gt; In order to work with the ChannelControl module the snrEval&#10;// module has to be called &quot;snrEval&quot; in the ned file.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @see BasicMacLayer, BasicDecider, BasicSnrEval&#10;// @author Marc Loebbers&#10;//&#10;"/>
  <tag type="compound-module" name="Nop" htmlfile="Nop-id225434.html" nedfile="Base/Nop.ned" comment="//&#10;// Just lets messages through without any change or delay.&#10;//&#10;"/>
  <tag type="compound-module" name="OSPFRouter" htmlfile="OSPFRouter-id257692.html" nedfile="Nodes/INET/OSPFRouter.ned" comment="//&#10;// \IP router.&#10;//&#10;"/>
  <tag type="compound-module" name="PPPInterface" htmlfile="PPPInterface-id253450.html" nedfile="NetworkInterfaces/PPP/PPPInterface.ned" comment="//&#10;// \PPP interface. Complements the PPP module with an output queue&#10;// for QoS and RED support.&#10;//&#10;// @see PPPInterfaceNoQueue&#10;//&#10;"/>
  <tag type="compound-module" name="PPPInterfaceNoQueue" htmlfile="PPPInterfaceNoQueue-id253676.html" nedfile="NetworkInterfaces/PPP/PPPInterfaceNoQueue.ned" comment="//&#10;// \PPP interface. Assumes inifinite queue.&#10;//&#10;// @see PPPInterface&#10;//&#10;"/>
  <tag type="compound-module" name="QuaggaRouter" htmlfile="QuaggaRouter-id258126.html" nedfile="Nodes/INET/QuaggaRouter.ned" comment="//&#10;// Quagga-based \IP router.&#10;//&#10;"/>
  <tag type="compound-module" name="RSVP_FAILED" htmlfile="RSVP_FAILED-id264094.html" nedfile="Nodes/MPLS/RSVP_FAILED.ned" comment="//&#10;// Failed router. Discards all incoming traffic and generates nothing. Its&#10;// interface (gates, parameters) is fully compatible with the RSVP_LSR router&#10;// and node failures may thus be simulated by replacing the RSVP_LSR&#10;// with \FAILED_LSR.&#10;//&#10;"/>
  <tag type="compound-module" name="RSVP_LSR" htmlfile="RSVP_LSR-id264429.html" nedfile="Nodes/MPLS/RSVP_LSR.ned" comment="//&#10;// An \RSVP-TE capable router.&#10;//&#10;// \RSVP occupies the Transport layer; however, it is not a transport protocol&#10;// itself. \RSVP uses transport protocols to route packets. TED is used&#10;// to calculate shortest paths.&#10;//&#10;"/>
  <tag type="compound-module" name="RTPHost" htmlfile="RTPHost-id269911.html" nedfile="Transport/RTP/RTPHost.ned" comment=""/>
  <tag type="compound-module" name="RTPLayer" htmlfile="RTPLayer-id270474.html" nedfile="Transport/RTP/RTPLayer.ned" comment=""/>
  <tag type="compound-module" name="Router" htmlfile="Router-id259068.html" nedfile="Nodes/INET/Router.ned" comment="//&#10;// \IP router.&#10;//&#10;"/>
  <tag type="compound-module" name="Router6" htmlfile="Router6-id261869.html" nedfile="Nodes/IPv6/Router6.ned" comment="//&#10;// \IPv6 router.&#10;//&#10;"/>
  <tag type="compound-module" name="SnrNic" htmlfile="SnrNic-id250860.html" nedfile="NetworkInterfaces/MF80211/SnrNic.ned" comment="// This is the easiest nic to implement &quot;real&quot; network behaviour. It uses&#10;// the CsmaMacLayer and the SnrDecider and SnrEval modules.&#10;//&#10;// The csma mac provides basic medium access and is used here to prevent a&#10;// host from trying to send a message while it is still in receive mode.&#10;//&#10;// The phy layer modules allow to account for collision and take fading into&#10;// account so that messages can actually be lost.&#10;//&#10;// IMPORTANT:&lt;br&gt; In order to work with the ChannelControl module the snrEval&#10;// module has to be called &quot;snrEval&quot; in the ned file.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @see BasicMacLayer, SnrDecider, SnrEval&#10;//&#10;// @author Daniel Willkomm&#10;"/>
  <tag type="compound-module" name="StandardHost" htmlfile="StandardHost-id259540.html" nedfile="Nodes/INET/StandardHost.ned" comment="//&#10;// \IP host with TCP, UDP layers and applications.&#10;//&#10;"/>
  <tag type="compound-module" name="StandardHost6" htmlfile="StandardHost6-id262388.html" nedfile="Nodes/IPv6/StandardHost6.ned" comment="//&#10;// \IPv6 host with TCP, UDP layers and applications.&#10;//&#10;"/>
  <tag type="compound-module" name="TCPSpoofingHost" htmlfile="TCPSpoofingHost-id260559.html" nedfile="Nodes/INET/TCPSpoofingHost.ned" comment="//&#10;// \IP host with TCPSpoof in the application layer.&#10;//&#10;"/>
  <tag type="compound-module" name="WirelessAP" htmlfile="WirelessAP-id265146.html" nedfile="Nodes/Wireless/WirelessAP.ned" comment="//&#10;// Models a 802.11 Access Point. It can be used in conjunction with&#10;// WirelessHost, or any other host model containing WirelessNicSTA.&#10;//&#10;// @see WirelessAP, WirelessAPSimplified, WirelessAPWithEth, WirelessAPWithEthSimplified&#10;// @see WirelessHost, WirelessHostSimplified&#10;// @see MobileHost, MFMobileHost&#10;//&#10;"/>
  <tag type="compound-module" name="WirelessAPSimplified" htmlfile="WirelessAPSimplified-id265337.html" nedfile="Nodes/Wireless/WirelessAPSimplified.ned" comment="//&#10;// Models a 802.11 Access Point, but using a simplified NIC that does not&#10;// support handovers. It should be used in conjunction with WirelessHostSimplified,&#10;// or any other host model containing WirelessNicSTASimplified.&#10;//&#10;// @see WirelessAP, WirelessAPSimplified, WirelessAPWithEth, WirelessAPWithEthSimplified&#10;// @see WirelessHost, WirelessHostSimplified&#10;// @see MobileHost, MFMobileHost&#10;//&#10;"/>
  <tag type="compound-module" name="WirelessAPWithEth" htmlfile="WirelessAPWithEth-id265538.html" nedfile="Nodes/Wireless/WirelessAPWithEth.ned" comment="//&#10;// Models a 802.11 Access Point with Ethernet ports.&#10;// It can be used in conjunction with WirelessHost, or any other host model&#10;// containing WirelessNicSTA.&#10;//&#10;// @see WirelessAP, WirelessAPSimplified, WirelessAPWithEth, WirelessAPWithEthSimplified&#10;// @see WirelessHost, WirelessHostSimplified&#10;// @see MobileHost, MFMobileHost&#10;//&#10;"/>
  <tag type="compound-module" name="WirelessAPWithEthSimplified" htmlfile="WirelessAPWithEthSimplified-id265866.html" nedfile="Nodes/Wireless/WirelessAPWithEthSimplified.ned" comment="//&#10;// Models a 802.11 Access Point with Ethernet ports, but using a simplified NIC&#10;// that does not support handovers. It can be used in conjunction with&#10;// WirelessHostSimplified, or any other host model containing WirelessNicSTASimplified.&#10;//&#10;// @see WirelessAP, WirelessAPSimplified, WirelessAPWithEth, WirelessAPWithEthSimplified&#10;// @see WirelessHost, WirelessHostSimplified&#10;// @see MobileHost, MFMobileHost&#10;//&#10;"/>
  <tag type="compound-module" name="WirelessHost" htmlfile="WirelessHost-id266620.html" nedfile="Nodes/Wireless/WirelessHost.ned" comment="//&#10;// Models a host with one wireless (802.11b) card in infrastructure mode.&#10;// This module is basically a StandardHost with an Ieee80211NicSTA added.&#10;// It should be used in conjunction with WirelessAP, or any other AP model&#10;// which contains Ieee80211NicAP.&#10;//&#10;// @see WirelessAP, WirelessAPSimplified, WirelessAPWithEth, WirelessAPWithEthSimplified&#10;// @see WirelessHost, WirelessHostSimplified&#10;// @see MobileHost, MFMobileHost&#10;//&#10;"/>
  <tag type="compound-module" name="WirelessHostSimplified" htmlfile="WirelessHostSimplified-id267586.html" nedfile="Nodes/Wireless/WirelessHostSimplified.ned" comment="//&#10;// Models a host with one wireless (802.11b) card in infrastructure mode,&#10;// but using a simplified NIC that does not support handovers.&#10;// This module is basically a StandardHost with an Ieee80211NicSTASimplified&#10;// added. It should be used in conjunction with WirelessAPSimplified,&#10;// or any other AP model which contains Ieee80211NicAPSimplified.&#10;//&#10;// @see WirelessAP, WirelessAPSimplified, WirelessAPWithEth, WirelessAPWithEthSimplified&#10;// @see WirelessHost, WirelessHostSimplified&#10;// @see MobileHost, MFMobileHost&#10;//&#10;"/>
  <tag type="enum" name="ARPOpcode" htmlfile="ARPOpcode-id227401.html" nedfile="Network/ARP/ARPPacket.msg" comment="//&#10;// The list of practically important ARP opcodes&#10;//&#10;"/>
  <tag type="enum" name="EtherType" htmlfile="EtherType-id239180.html" nedfile="NetworkInterfaces/Contract/Ieee802Ctrl.msg" comment="//&#10;// Some EtherType values (Ethernet II).&#10;//&#10;"/>
  <tag type="enum" name="ICMPType" htmlfile="ICMPType-id231540.html" nedfile="Network/IPv4/ICMPMessage.msg" comment="//&#10;// Not the real ICMP codes; here it's set up so that codes above 128 are&#10;// informational&#10;//&#10;"/>
  <tag type="enum" name="ICMPv6DEST_UN" htmlfile="ICMPv6DEST_UN-id229547.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// ICMPv6 &quot;codes&quot; for type ICMPv6_DESTINATION_UNREACHABLE&#10;//&#10;"/>
  <tag type="enum" name="ICMPv6Type" htmlfile="ICMPv6Type-id229410.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment=""/>
  <tag type="enum" name="ICMPv6_PARAMETER_PROB" htmlfile="ICMPv6_PARAMETER_PROB-id229663.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// ICMPv6 &quot;codes&quot; for type ICMPv6_PARAMETER_PROBLEM&#10;//&#10;"/>
  <tag type="enum" name="ICMPv6_TIME_EX" htmlfile="ICMPv6_TIME_EX-id229630.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// ICMPv6 &quot;codes&quot; for type ICMPv6_TIME_EXCEEDED&#10;//&#10;"/>
  <tag type="enum" name="IPOption" htmlfile="IPOption-id231873.html" nedfile="Network/IPv4/IPDatagram.msg" comment="//&#10;// IP options. Beware: these are not the &quot;official&quot; (RFC) codes!&#10;//&#10;"/>
  <tag type="enum" name="IPProtocolId" htmlfile="IPProtocolId-id228413.html" nedfile="Network/Contract/IPProtocolId.msg" comment="//&#10;// Protocol field: taken from RFC 1700.&#10;// Replacing old RFC1700 with newer (28/06/01) Protocol Numbers&#10;//&#10;"/>
  <tag type="enum" name="Ieee80211BSSType" htmlfile="Ieee80211BSSType-id249298.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment=""/>
  <tag type="enum" name="Ieee80211FrameType" htmlfile="Ieee80211FrameType-id246102.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// 802.11 frame type constants (type+subtype), for the &quot;type&quot; field of&#10;// Ieee80211FrameControl&#10;//&#10;"/>
  <tag type="enum" name="Ieee80211PrimConfirmCode" htmlfile="Ieee80211PrimConfirmCode-id249230.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// IEEE 802.11 confirm codes, sent by the management entity to the agent,&#10;// in response to the agents's requests.&#10;// These constants should be set as message kind on the messages.&#10;//&#10;// @see Ieee80211PrimRequestCode, Ieee80211MgmtSTA, Ieee80211AgentSTA&#10;//&#10;"/>
  <tag type="enum" name="Ieee80211PrimRequestCode" htmlfile="Ieee80211PrimRequestCode-id249529.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// IEEE 802.11 command codes, sent by the agent to the management entity.&#10;// These constants should be set as message kind on the messages.&#10;//&#10;// @see Ieee80211PrimConfirmCode, Ieee80211MgmtSTA, Ieee80211AgentSTA&#10;//&#10;"/>
  <tag type="enum" name="Ieee80211PrimResultCode" htmlfile="Ieee80211PrimResultCode-id249339.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Primitives.msg" comment="//&#10;// Values for the resultCode field in confirm primitives, sent from&#10;// the management entity to the agent.&#10;//&#10;// @see Ieee80211PrimConfirmCode, Ieee80211MgmtSTA, Ieee80211AgentSTA&#10;//&#10;"/>
  <tag type="enum" name="Ieee80211ReasonCode" htmlfile="Ieee80211ReasonCode-id247930.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// 802.11 reason code; values correspond to the standard.&#10;//&#10;"/>
  <tag type="enum" name="Ieee80211StatusCode" htmlfile="Ieee80211StatusCode-id248018.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// 802.11 status code; values correspond to the standard.&#10;//&#10;"/>
  <tag type="enum" name="Ieee802MessageKind" htmlfile="Ieee802MessageKind-id239014.html" nedfile="NetworkInterfaces/Contract/Ieee802Ctrl.msg" comment="//&#10;// Message kind values used with in communication between L3 and IEEE 802 L2&#10;//&#10;"/>
  <tag type="enum" name="LDP_MESSAGE_TYPES" htmlfile="LDP_MESSAGE_TYPES-id233375.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP message types&#10;//&#10;"/>
  <tag type="enum" name="LDP_STATUS_TYPES" htmlfile="LDP_STATUS_TYPES-id233420.html" nedfile="Network/LDP/LDPPacket.msg" comment=""/>
  <tag type="enum" name="LSAType" htmlfile="LSAType-id234538.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment=""/>
  <tag type="enum" name="LinkType" htmlfile="LinkType-id234716.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment=""/>
  <tag type="enum" name="ManetControlType" htmlfile="ManetControlType-id231170.html" nedfile="Network/IPv4/ControlManetRouting.msg" comment=""/>
  <tag type="enum" name="OSPFPacketType" htmlfile="OSPFPacketType-id234343.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment=""/>
  <tag type="enum" name="OSPFTimerType" htmlfile="OSPFTimerType-id235585.html" nedfile="Network/OSPFv2/OSPFTimer.msg" comment=""/>
  <tag type="enum" name="PhyCommandCode" htmlfile="PhyCommandCode-id239398.html" nedfile="NetworkInterfaces/Contract/PhyControlInfo.msg" comment="//&#10;// Command codes for controlling the physical layer (the radio). These constants&#10;// should be set as message kind on a message sent to the radio module.&#10;//&#10;// @see PhyControlInfo&#10;//&#10;"/>
  <tag type="enum" name="SAPCode" htmlfile="SAPCode-id239099.html" nedfile="NetworkInterfaces/Contract/Ieee802Ctrl.msg" comment="//&#10;// Some 8-bit SAP values for IEEE 802.x LLC headers.&#10;//&#10;"/>
  <tag type="enum" name="TCPErrorCode" htmlfile="TCPErrorCode-id268526.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// Currently not in use.&#10;//&#10;"/>
  <tag type="enum" name="TcpCommandCode" htmlfile="TcpCommandCode-id268675.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// \TCP command codes, sent by the application to TCP. These constants&#10;// should be set as message kind on a message sent to the TCP entity.&#10;//&#10;// @see TCPCommand, TCPOpenCommand, TCP&#10;//&#10;"/>
  <tag type="enum" name="TcpStatusInd" htmlfile="TcpStatusInd-id268763.html" nedfile="Transport/Contract/TCPCommand.msg" comment="//&#10;// \TCP indications, sent by TCP to the application. TCP will set these&#10;// constants as message kind on messages it sends to the application.&#10;//&#10;// @see TCPCommand, TCPStatusInfo, TCP&#10;//&#10;"/>
  <tag type="enum" name="TimestampFlag" htmlfile="TimestampFlag-id231930.html" nedfile="Network/IPv4/IPDatagram.msg" comment="//&#10;// The timestamp flag uses the same numeric values as the IP Protocol&#10;//&#10;"/>
  <tag type="enum" name="UDPCommandCode" htmlfile="UDPCommandCode-id269217.html" nedfile="Transport/Contract/UDPControlInfo.msg" comment="//&#10;// \UDP command codes, sent by the application to UDP. These constants&#10;// should be set as message kind on a message sent to the UDP entity.&#10;//&#10;// @see UDPControlInfo, UDPStatusInd, UDP&#10;//&#10;"/>
  <tag type="enum" name="UDPStatusInd" htmlfile="UDPStatusInd-id269289.html" nedfile="Transport/Contract/UDPControlInfo.msg" comment="//&#10;// \UDP indications, sent by UDP to the application. UDP will set these&#10;// constants as message kind on messages it sends to the application.&#10;//&#10;// @see UDPControlInfo, UDPCommandCode, UDP&#10;//&#10;"/>
  <tag type="message" name="ARPPacket" htmlfile="ARPPacket-id227492.html" nedfile="Network/ARP/ARPPacket.msg" comment="//&#10;// ARP packet. This is a specialized version: prepared for IEEE 802 hardware&#10;// addresses and IPv4. Packet fields are therefore represented by C++ classes&#10;// MACAddress and IPAddress. Also, some ARP protocol header fields are&#10;// not modelled explicitly (their values are implied):&#10;//   - hardwareType (not needed for modelling);&#10;//   - protocol type (0x800 IPv4)&#10;//   - hardware address length (6)&#10;//   - protocol address length (4)&#10;//&#10;"/>
  <tag type="message" name="AirFrame" htmlfile="AirFrame-id252991.html" nedfile="NetworkInterfaces/MFCore/AirFrame.msg" comment="//&#10;// Format of the messages that are sent to the channel&#10;//&#10;// subclass if you want to create your own AirFrame message class&#10;//&#10;// This message format is used to send a packet from a snrEval module&#10;// to the channel. All other snrEval modules that can 'hear' this&#10;// message can evaluate noise, interference etc. from the information&#10;// contained in this message:&#10;//&#10;// If you need more fields for whatever reason, please do NOT create&#10;// your own message! Just extend (subclass) this message format (see Omnet&#10;// manual,chapter Messages - Inheritance among message classes).&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @todo As soon as opp_msgc also supports pointers we should replace&#10;// the id with a pointer to the nodes coordinates itself.&#10;// @author Marc Loebbers&#10;//&#10;"/>
  <tag type="message" name="ByteArrayMessage" htmlfile="ByteArrayMessage-id225697.html" nedfile="Base/ByteArrayMessage.msg" comment="//&#10;// Message that carries raw bytes. Used with emulation-related features.&#10;//&#10;"/>
  <tag type="message" name="ControlManetRouting" htmlfile="ControlManetRouting-id231339.html" nedfile="Network/IPv4/ControlManetRouting.msg" comment="//&#10;// ICMP message class&#10;//&#10;"/>
  <tag type="message" name="EtherAppReq" htmlfile="EtherAppReq-id223505.html" nedfile="Applications/Ethernet/EtherApp.msg" comment="//&#10;// Request packet sent by EtherAppCli. Contains the number of bytes to be&#10;// sent back as response; if this value is greater than ~1400, the reply&#10;// will consist of several Ethernet frames. See also EtherAppResp.&#10;//&#10;"/>
  <tag type="message" name="EtherAppResp" htmlfile="EtherAppResp-id223579.html" nedfile="Applications/Ethernet/EtherApp.msg" comment="//&#10;// Packet sent back by EtherAppSrv in response to an EtherAppReq.&#10;//&#10;"/>
  <tag type="message" name="EtherAutoconfig" htmlfile="EtherAutoconfig-id242601.html" nedfile="NetworkInterfaces/Ethernet/EtherFrame.msg" comment="//&#10;// Ethernet model components (EtherMAC, EtherHub and EtherBus) send this&#10;// message at the beginning of the simulation, so that &quot;auto&quot;-valued &quot;txrate&quot;&#10;// and &quot;duplex&quot; parameters of EtherMAC can be initialized. The purpose is&#10;// similar to Ethernet Auto-Negotiation; however this is NOT meant to be&#10;// the model of that Ethernet feature. (For example, EtherBus also sends&#10;// an EtherAutoconfig message in the model, which obviously does not happen in&#10;// a real Ethernet.)&#10;//&#10;// - txrate: EtherMAC with non-auto txrate send configured txrate value;&#10;//   EtherBus sends 10Mbps (0 means not set). Lowest value will be chosen by&#10;//   all EtherMACs, or if no txrate was advertised (all were 0), 100Mbps is chosen.&#10;// - halfDuplex: EtherHub, EtherBus, plus EtherMAC with duplexEnabled=false setting&#10;//   send true. Duplex operation only chosen by a MAC if nobody vetoed it by sending&#10;//   halfDuplex=true.&#10;//&#10;"/>
  <tag type="message" name="EtherFrame" htmlfile="EtherFrame-id242304.html" nedfile="NetworkInterfaces/Ethernet/EtherFrame.msg" comment="//&#10;// Common base class for classes representing Ethernet II and 802.3 frame types,&#10;// containing their common header fields.&#10;//&#10;// This class should never be instantiated by the models, only specific&#10;// subclasses: EthernetIIFrame, EtherFrameWithLLC and EtherFrameWithSNAP.&#10;//&#10;// Source and destination MAC address are stored in data members.&#10;// Other fields include:&#10;//  - preamble: not stored (only contributes length)&#10;//  - length: stored in cMessage::length(), not stored explicitly&#10;//  - payload: stored a encapsulated packet (cMessage::encapsulate())&#10;//  - crc: represented by cMessage::hasBitError()&#10;//&#10;"/>
  <tag type="message" name="EtherFrameWithLLC" htmlfile="EtherFrameWithLLC-id242381.html" nedfile="NetworkInterfaces/Ethernet/EtherFrame.msg" comment="//&#10;// Ethernet frame with 802.3 LLC header.&#10;//&#10;// Header length: src(6)+dest(6)+length(2)+ssap(1)+dsap(1)+control(1) = 17 bytes&#10;//&#10;"/>
  <tag type="message" name="EtherFrameWithSNAP" htmlfile="EtherFrameWithSNAP-id242494.html" nedfile="NetworkInterfaces/Ethernet/EtherFrame.msg" comment="//&#10;// Ethernet frame with 802.3 LLC and SNAP headers.&#10;//&#10;// The fields ssap, dsap and control are not included in the class because&#10;// they are always set to fixed values: 0xAA, 0xAA, 0x03.&#10;//&#10;// Header length: src(6)+dest(6)+length(2)+ssap(1)+dsap(1)+control(1)+&#10;// orgCode(3)+localCode(2) = 22 bytes&#10;//&#10;"/>
  <tag type="message" name="EtherPauseFrame" htmlfile="EtherPauseFrame-id242543.html" nedfile="NetworkInterfaces/Ethernet/EtherFrame.msg" comment="//&#10;// Ethernet frame used by the PAUSE protocol&#10;//&#10;"/>
  <tag type="message" name="EthernetIIFrame" htmlfile="EthernetIIFrame-id242350.html" nedfile="NetworkInterfaces/Ethernet/EtherFrame.msg" comment="//&#10;// Ethernet II headers contain a 16-bit EtherType to identify&#10;// the encapsulated protocol.&#10;//&#10;// Header length: src(6)+dest(6)+etherType(2) = 14 bytes&#10;//&#10;"/>
  <tag type="message" name="GenericAppMsg" htmlfile="GenericAppMsg-id224442.html" nedfile="Applications/TCPApp/GenericAppMsg.msg" comment="//&#10;// Message class for generic request-reply style applications.&#10;// The client sends a GenericAppMsg which contains the number of&#10;// bytes the client wants the server to send back as reply.&#10;//&#10;// This way intelligence (behaviour specific to the modelled application,&#10;// e.g. HTTP, SMB, database protocol) needs only to be present in&#10;// the client, and the server model can be kept simple and dumb.&#10;//&#10;// @see TCPGenericSrvApp, TCPGenericCliAppBase (C++ only)&#10;//&#10;"/>
  <tag type="message" name="HelloTimeoutMsg" htmlfile="HelloTimeoutMsg-id238278.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="HelloTimerMsg" htmlfile="HelloTimerMsg-id238236.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="ICMPMessage" htmlfile="ICMPMessage-id231457.html" nedfile="Network/IPv4/ICMPMessage.msg" comment="//&#10;// ICMP message class&#10;//&#10;"/>
  <tag type="message" name="ICMPv6DestUnreachableMsg" htmlfile="ICMPv6DestUnreachableMsg-id229748.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// Notes:&#10;//   1. As defined in RFC2463: Section 3&#10;//&#10;"/>
  <tag type="message" name="ICMPv6EchoReplyMsg" htmlfile="ICMPv6EchoReplyMsg-id229989.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// ICMPv6 Echo Reply packet. Data is attached through encapsulation (see ICMPv6.cc)&#10;//&#10;"/>
  <tag type="message" name="ICMPv6EchoRequestMsg" htmlfile="ICMPv6EchoRequestMsg-id229920.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// ICMPv6 Echo Request packet (RFC2463: Section 4).&#10;// Data is attached through encapsulation (see ICMPv6.cc)&#10;//&#10;"/>
  <tag type="message" name="ICMPv6Message" htmlfile="ICMPv6Message-id229703.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment="//&#10;// Represents an ICMPv6 packet.&#10;//&#10;// Notes:&#10;//    1. number of octets excluding the error datagram that is usually appended&#10;//       in optInfo, i.e. the Type|CODE|CHECKSUM|UNUSED/POINTER/MTU/OTHER&#10;//       as defined in RFC2463&#10;//    2. Any ICMP type with MSB set, i.e. &gt;=128 is an Informational ICMP message&#10;//&#10;"/>
  <tag type="message" name="ICMPv6PacketTooBigMsg" htmlfile="ICMPv6PacketTooBigMsg-id229790.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment=""/>
  <tag type="message" name="ICMPv6ParamProblemMsg" htmlfile="ICMPv6ParamProblemMsg-id229880.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment=""/>
  <tag type="message" name="ICMPv6TimeExceededMsg" htmlfile="ICMPv6TimeExceededMsg-id229841.html" nedfile="Network/ICMPv6/ICMPv6Message.msg" comment=""/>
  <tag type="message" name="IPDatagram" htmlfile="IPDatagram-id232002.html" nedfile="Network/IPv4/IPDatagram.msg" comment="//&#10;// Represents an IP datagram.&#10;//&#10;// Uses the following cMessage fields:&#10;//    - length () / setLength(err)  in bits&#10;//    - hasBitError() / setBitError()&#10;//    - timestamp() / setTimestamp (simtime) used in timestamp option&#10;//&#10;// Additional length fields defined in this class are in bytes&#10;// (totalLength()=length()/8 and header_length), or 8 bytes (fragment_offset).&#10;//&#10;// Only only one of the option fields can exist at a time.&#10;//&#10;"/>
  <tag type="message" name="IPv6Datagram" htmlfile="IPv6Datagram-id232560.html" nedfile="Network/IPv6/IPv6Datagram.msg" comment="//&#10;// IPv6 datagram. RFC 2460 Section 3.&#10;//&#10;// Header fields not explicitly modelled:&#10;//    - version (=6): represented by the class name itself&#10;//    - payload length: will be calculated from encapsulated message length&#10;//      and extension headers' length&#10;//&#10;"/>
  <tag type="message" name="IPv6NDMessage" htmlfile="IPv6NDMessage-id230159.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// Neighbour Discovery for IPv6.&#10;// RFC 2461&#10;//&#10;// ICMP fields inherited from ICMPv6Message:&#10;//    - Type&#10;//&#10;// ICMP fields not implemented:&#10;//    - Checksum&#10;//    - Reserved&#10;//&#10;"/>
  <tag type="message" name="IPv6NeighbourAdvertisement" htmlfile="IPv6NeighbourAdvertisement-id230500.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// Neighbour Advertisement Message Format&#10;// RFC 2461 Section 4.4&#10;//&#10;"/>
  <tag type="message" name="IPv6NeighbourSolicitation" htmlfile="IPv6NeighbourSolicitation-id230452.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// Neighbour Solicitation Message Format&#10;// RFC 2461 Section 4.3&#10;//&#10;"/>
  <tag type="message" name="IPv6Redirect" htmlfile="IPv6Redirect-id230577.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// Redirect Message Format&#10;// RFC 2461 Section 4.5&#10;//&#10;"/>
  <tag type="message" name="IPv6RouterAdvertisement" htmlfile="IPv6RouterAdvertisement-id230337.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// Router Advertisement Message Format&#10;// RFC 2461 Section 4.2&#10;//&#10;"/>
  <tag type="message" name="IPv6RouterSolicitation" htmlfile="IPv6RouterSolicitation-id230206.html" nedfile="Network/ICMPv6/IPv6NDMessage.msg" comment="//&#10;// Router Solicitation Message Format&#10;// RFC 2461 Section 4.1&#10;//&#10;"/>
  <tag type="message" name="Ieee80211ACKFrame" htmlfile="Ieee80211ACKFrame-id246482.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Format of the 802.11 ACK frame&#10;//&#10;"/>
  <tag type="message" name="Ieee80211AssociationRequestFrame" htmlfile="Ieee80211AssociationRequestFrame-id248919.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Association request frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211AssociationResponseFrame" htmlfile="Ieee80211AssociationResponseFrame-id249015.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Association response frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211AuthenticationFrame" htmlfile="Ieee80211AuthenticationFrame-id248729.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Authentication frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211BeaconFrame" htmlfile="Ieee80211BeaconFrame-id249112.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Beacon frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211CTSFrame" htmlfile="Ieee80211CTSFrame-id246580.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Format of the 802.11 CTS frame&#10;//&#10;"/>
  <tag type="message" name="Ieee80211DataFrame" htmlfile="Ieee80211DataFrame-id246660.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Format of the 802.11 data frame&#10;//&#10;"/>
  <tag type="message" name="Ieee80211DataOrMgmtFrame" htmlfile="Ieee80211DataOrMgmtFrame-id246609.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Common base class for 802.11 data and management frames&#10;//&#10;"/>
  <tag type="message" name="Ieee80211DeauthenticationFrame" htmlfile="Ieee80211DeauthenticationFrame-id248776.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// De-authentication frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211DisassociationFrame" htmlfile="Ieee80211DisassociationFrame-id248824.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Dis-association frame format (management frame + body) (same as De-authentication)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211Frame" htmlfile="Ieee80211Frame-id246263.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// The common part of 802.11 frames. &#10;//&#10;// NOTE:&#10;// FCS value is not explicitly modeled, but it is included in the length.&#10;// Frame control format fields not supported by this model are omitted:&#10;// MoreFlag, PowerMgmt, MoreData, WEP, Order.&#10;//&#10;"/>
  <tag type="message" name="Ieee80211ManagementFrame" htmlfile="Ieee80211ManagementFrame-id246704.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Base class for 802.11 management frames (subclasses will add frame body contents)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211OneAddressFrame" htmlfile="Ieee80211OneAddressFrame-id246465.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Format of a 802.11 frame with address1 present, like ACK and CTS&#10;//&#10;"/>
  <tag type="message" name="Ieee80211ProbeRequestFrame" htmlfile="Ieee80211ProbeRequestFrame-id248872.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Probe request frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211ProbeResponseFrame" htmlfile="Ieee80211ProbeResponseFrame-id249155.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Probe response frame format (management frame + body); same as Beacon&#10;//&#10;"/>
  <tag type="message" name="Ieee80211RTSFrame" htmlfile="Ieee80211RTSFrame-id246551.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Format of the 802.11 RTS frame&#10;//&#10;"/>
  <tag type="message" name="Ieee80211ReassociationRequestFrame" htmlfile="Ieee80211ReassociationRequestFrame-id248967.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Re-association request frame format (management frame + body) (same as association)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211ReassociationResponseFrame" htmlfile="Ieee80211ReassociationResponseFrame-id249063.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Re-association response frame format (management frame + body)&#10;//&#10;"/>
  <tag type="message" name="Ieee80211TwoAddressFrame" htmlfile="Ieee80211TwoAddressFrame-id246510.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Frame.msg" comment="//&#10;// Format of a 802.11 frame with address1 and address2 present&#10;//&#10;"/>
  <tag type="message" name="LDPAddress" htmlfile="LDPAddress-id233725.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP Address Message&#10;//&#10;//# FIXME currently unused&#10;"/>
  <tag type="message" name="LDPHello" htmlfile="LDPHello-id233592.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP Hello Message&#10;//&#10;"/>
  <tag type="message" name="LDPIni" htmlfile="LDPIni-id233668.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP Ini Message&#10;//&#10;//# FIXME currently unused&#10;"/>
  <tag type="message" name="LDPLabelMapping" htmlfile="LDPLabelMapping-id233528.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP Label Mapping Message&#10;//&#10;"/>
  <tag type="message" name="LDPLabelRequest" htmlfile="LDPLabelRequest-id233564.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP Label Request Message&#10;//&#10;"/>
  <tag type="message" name="LDPNotify" htmlfile="LDPNotify-id233634.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// LDP notification message&#10;//&#10;"/>
  <tag type="message" name="LDPPacket" htmlfile="LDPPacket-id233476.html" nedfile="Network/LDP/LDPPacket.msg" comment="//&#10;// Base class for LDP packets&#10;//&#10;"/>
  <tag type="message" name="LinkStateMsg" htmlfile="LinkStateMsg-id238531.html" nedfile="Network/TED/LinkStatePacket.msg" comment="//&#10;// Packet for disseminating link state information (TELinkStateInfo[]) by the&#10;// LinkStateRouting module which implements a minimalistic link state routing&#10;// protocol.&#10;//&#10;"/>
  <tag type="message" name="Mac80211Pkt" htmlfile="Mac80211Pkt-id251348.html" nedfile="NetworkInterfaces/MF80211/macLayer/Mac80211Pkt.msg" comment="//&#10;// Defines all fields of an 802.11 MAC frame&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="message" name="MacPkt" htmlfile="MacPkt-id251542.html" nedfile="NetworkInterfaces/MF80211/macLayer/MacPkt.msg" comment="//&#10;// A basic MAC (Media Access Control) packet format definition&#10;//&#10;// subclass if you want to create your own MAC layer message class&#10;//&#10;// The basic MAC message only provides source and destination address&#10;// and and the channel it should be send on&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @author Daniel Willkomm&#10;//&#10;//# FIXME just temporary here&#10;//&#10;"/>
  <tag type="message" name="OSPFDatabaseDescriptionPacket" htmlfile="OSPFDatabaseDescriptionPacket-id235275.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Database Description packet&#10;//&#10;"/>
  <tag type="message" name="OSPFHelloPacket" htmlfile="OSPFHelloPacket-id234436.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Hello packet&#10;//&#10;"/>
  <tag type="message" name="OSPFLinkStateAcknowledgementPacket" htmlfile="OSPFLinkStateAcknowledgementPacket-id235483.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Link State Acknowledgement packet&#10;//&#10;"/>
  <tag type="message" name="OSPFLinkStateRequestPacket" htmlfile="OSPFLinkStateRequestPacket-id235379.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Link State Request packet&#10;//&#10;"/>
  <tag type="message" name="OSPFLinkStateUpdatePacket" htmlfile="OSPFLinkStateUpdatePacket-id235411.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF Link State Update packet&#10;//&#10;"/>
  <tag type="message" name="OSPFPacket" htmlfile="OSPFPacket-id234132.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="//&#10;// Represents an OSPF packet header&#10;//&#10;"/>
  <tag type="message" name="OSPFTimer" htmlfile="OSPFTimer-id235647.html" nedfile="Network/OSPFv2/OSPFTimer.msg" comment="//&#10;// Represents an OSPF Timer&#10;//&#10;"/>
  <tag type="message" name="PPPFrame" htmlfile="PPPFrame-id253928.html" nedfile="NetworkInterfaces/PPP/PPPFrame.msg" comment="//&#10;// PPP frame.&#10;//&#10;// Constant-value header fields are not modelled:&#10;// Flag (=0x7e), address (=0xff), control (=0x03), CRC (bitError())&#10;//&#10;// CRC is modelled only via cMessage's bit error attribute.&#10;//&#10;// Protocol field is not modelled because types of encapsulated messages&#10;// wil be determined from their class (using C++ dynamic_cast).&#10;//&#10;"/>
  <tag type="message" name="PathNotifyMsg" htmlfile="PathNotifyMsg-id238319.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="PingPayload" htmlfile="PingPayload-id219595.html" nedfile="Applications/PingApp/PingPayload.msg" comment="//&#10;// Represents payload in an ICMP/ICMPv6 Echo Request/Reply.&#10;//&#10;"/>
  <tag type="message" name="PsbTimeoutMsg" htmlfile="PsbTimeoutMsg-id238074.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="PsbTimerMsg" htmlfile="PsbTimerMsg-id237946.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPHelloMsg" htmlfile="RSVPHelloMsg-id237029.html" nedfile="Network/RSVP_TE/RSVPHello.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPMessage" htmlfile="RSVPMessage-id237252.html" nedfile="Network/RSVP_TE/RSVPPacket.msg" comment="//&#10;// \RSVP message common part&#10;//&#10;"/>
  <tag type="message" name="RSVPPacket" htmlfile="RSVPPacket-id237278.html" nedfile="Network/RSVP_TE/RSVPPacket.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPPathError" htmlfile="RSVPPathError-id237574.html" nedfile="Network/RSVP_TE/RSVPPathMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPPathMsg" htmlfile="RSVPPathMsg-id237497.html" nedfile="Network/RSVP_TE/RSVPPathMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPPathTear" htmlfile="RSVPPathTear-id237508.html" nedfile="Network/RSVP_TE/RSVPPathMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPResvError" htmlfile="RSVPResvError-id237838.html" nedfile="Network/RSVP_TE/RSVPResvMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPResvMsg" htmlfile="RSVPResvMsg-id237721.html" nedfile="Network/RSVP_TE/RSVPResvMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RSVPResvTear" htmlfile="RSVPResvTear-id237779.html" nedfile="Network/RSVP_TE/RSVPResvMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RsbCommitTimerMsg" htmlfile="RsbCommitTimerMsg-id238155.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RsbRefreshTimerMsg" htmlfile="RsbRefreshTimerMsg-id238114.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="RsbTimeoutMsg" htmlfile="RsbTimeoutMsg-id238196.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="SignallingMsg" htmlfile="SignallingMsg-id237919.html" nedfile="Network/RSVP_TE/SignallingMsg.msg" comment="//&#10;// FIXME missing documentation&#10;//&#10;"/>
  <tag type="message" name="SocketMsg" htmlfile="SocketMsg-id235800.html" nedfile="Network/Quagga/SocketMsg.msg" comment=""/>
  <tag type="message" name="TCPSegment" htmlfile="TCPSegment-id271106.html" nedfile="Transport/TCP/TCPSegment.msg" comment="//&#10;// Represents a \TCP segment, to be used with the TCP module.&#10;//&#10;// \TCP header fields not explicitly modelled:&#10;// - Data Offset (number of 32 bit words in the header): represented&#10;//   by cMessage::length().&#10;// - Reserved (reserved for future use)&#10;// - Checksum (header checksum): modelled by cMessage::hasBitError()&#10;// - Options: none supported currently (MSS comes from config)&#10;// - Padding&#10;//&#10;// cMessage::kind() may be set to an arbitrary value: TCP entities will&#10;// ignore it and use only the header fields (synBit, ackBit, rstBit).&#10;//&#10;"/>
  <tag type="message" name="TransmComplete" htmlfile="TransmComplete-id253070.html" nedfile="NetworkInterfaces/MFCore/TransmComplete.msg" comment="//&#10;// Timer to indicate a completely received frame&#10;//&#10;// This message class is used within BasicSnrEval to indicate that an&#10;// AirFrame is completely received. It has no parameters and was only&#10;// introduced to differentiate this timer from other self messages&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @author Daniel Willkomm&#10;//&#10;"/>
  <tag type="message" name="UDPEchoAppMsg" htmlfile="UDPEchoAppMsg-id225233.html" nedfile="Applications/UDPApp/UDPEchoAppMsg.msg" comment="//&#10;// Message class used by UDPEchoApp.&#10;//&#10;"/>
  <tag type="message" name="UDPPacket" htmlfile="UDPPacket-id272161.html" nedfile="Transport/UDP/UDPPacket.msg" comment="//&#10;// Represents an \UDP packet, to be used with the UDP module.&#10;//&#10;"/>
  <tag type="simple-module" name="ANSimMobility" htmlfile="ANSimMobility-id225804.html" nedfile="Mobility/ANSimMobility.ned" comment="//&#10;// Uses the &lt;position_change&gt; elements of the ANSim tool's&#10;// trace file.&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="ARP" htmlfile="ARP-id227137.html" nedfile="Network/ARP/ARP.ned" comment="//&#10;// Implements the Address Resolution Protocol for IPv4 and IEEE 802 6-byte &#10;// MAC addresses.&#10;//&#10;// Expects IPRoutingDecision control info objects to be attached to packets&#10;// coming from higher layers. \ARP packets are represented by the ARPPacket&#10;// class. Datagrams to be sent and incoming \ARP packets are expected to&#10;// on gate ipIn.&#10;//&#10;// \ARP resolution is used over &lt;i&gt;broadcast&lt;/i&gt; interfaces only,&#10;// that is, over interfaces that have the &lt;tt&gt;isBroadcast()&lt;/tt&gt; flag set in &#10;// &lt;tt&gt;InterfaceEntry&lt;/tt&gt; (see InterfaceTable). Since routing files &#10;// (&lt;tt&gt;.irt&lt;/tt&gt; or &lt;tt&gt;.mrt&lt;/tt&gt; files, given as parameter to RoutingTable)&#10;// may modify the default interface configuration, you must take care that&#10;// these files don't contain the word &lt;tt&gt;BROADCAST&lt;/tt&gt; e.g. for PPP&#10;// interfaces.&#10;//&#10;"/>
  <tag type="simple-module" name="BasicDecider" htmlfile="BasicDecider-id252553.html" nedfile="NetworkInterfaces/MFCore/BasicDecider.ned" comment="//&#10;// Module to decide whether a frame is received correctly or is&#10;// lost due to bit errors, interference...&#10;//&#10;// The decider module only handles messages from lower layers. All&#10;// messages from upper layers are directly passed to the snrEval layer&#10;// and cannot be processed in the decider module&#10;//&#10;// This is the basic decider module which does not really decide&#10;// anything. It only provides the basic functionality which all&#10;// decider modules should have, namely message de- &amp; encapsulation&#10;// (For further information about the functionality of the physical&#10;// layer modules and the formats used for communication in between&#10;// them have a look at the manual&#10;//&#10;// Every own decider module class should be derived from this class&#10;// and only the handle*Msg functions may be redefined for your own&#10;// needs. The other functions should usually NOT be changed.&#10;//&#10;// All decider modules should assume bits as a unit for the length&#10;// fields.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @author Marc L&#xF6;bbers, Daniel Willkomm&#10;//&#10;"/>
  <tag type="simple-module" name="BasicSnrEval" htmlfile="BasicSnrEval-id252457.html" nedfile="NetworkInterfaces/MFCore/BasicSnrEval.ned" comment="//&#10;// The basic class for all snrEval modules&#10;//&#10;// The BasicSnrEval module provides functionality like en- and&#10;// decapsulation of messages. If you use the standard message formats&#10;// everythng should work fine. Before a packet is sent some&#10;// information, e.g. transmission power, can be written to the&#10;// AirFrame header. If you write your own snrEval, just subclass and&#10;// redefine the handleUpperMsg function (see description of the&#10;// function). After receiving a message it can be processed in&#10;// handleLowerMsgStart. Then it is buffered for the time the&#10;// transmission would last in reality, and then can be handled&#10;// again. Again you can redefine the 1. handleLowerMsgStart and&#10;// 2. handleLowerMsgEnd for your own needs (see description). So, the&#10;// call of these functions represent the following events: 1. received&#10;// a message (i.e. transmission startet) 2. message will be handed on&#10;// to the upper layer (i.e. transmission time is over)&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @see SnrEval&#10;// @author Marc Loebbers&#10;//&#10;"/>
  <tag type="simple-module" name="Blackboard" htmlfile="Blackboard-id225307.html" nedfile="Base/Blackboard.ned" comment="//&#10;// Blackboard for sharing information among modules in a host or router.&#10;// Accessed via direct method calls.&#10;//&#10;"/>
  <tag type="simple-module" name="BonnMotionMobility" htmlfile="BonnMotionMobility-id225866.html" nedfile="Mobility/BonnMotionMobility.ned" comment="//&#10;// Uses the native file format of BonnMotion (http://www.cs.uni-bonn.de/IV/BonnMotion/).&#10;//&#10;// The file is a plain text file, where every line describes the motion&#10;// of one host. A line consists of one or more (t, x, y) triplets of real&#10;// numbers, like:&#10;//&#10;// t1 x1 y1 t2 x2 y2 t3 x3 y3 t4 x4 y4 ...&#10;//&#10;// The meaning is that the given node gets to (xk,yk) at tk. There's no&#10;// separate notation for wait, so x and y coordinates will be repeated there.&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="CSMAMacLayer" htmlfile="CSMAMacLayer-id251079.html" nedfile="NetworkInterfaces/MF80211/macLayer/CSMAMacLayer.ned" comment="//&#10;// CSMA MAC protocol&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="ChannelControl" htmlfile="ChannelControl-id272488.html" nedfile="World/ChannelControl.ned" comment="//&#10;// ChannelControl has exactly one instance in every network model that &#10;// contains mobile or wireless nodes. This module gets informed about the &#10;// location and movement of nodes, and determines which nodes are within&#10;// communication or interference distance. This info is then used by the &#10;// radio interfaces of nodes at transmissions.&#10;//&#10;// Side effect: updates the containing compound module's display string&#10;// according to the given playground size (sets &lt;tt&gt;&quot;p=0,0;b=$playgroundSizeX,&#10;// $playgroundSizeY&quot;&lt;/tt&gt;).&#10;//&#10;// This ChannelControl is a different implementation from the one in &#10;// Mobility Framework 1.0a5: here we use sendDirect(), while the MF version &#10;// used normal send() and dynamic connections.&#10;//&#10;// @author Andras Varga (based on MF's ChannelControl by Steffen Sroka and Daniel Willkomm)&#10;// @see BasicMobility&#10;//&#10;"/>
  <tag type="simple-module" name="ChannelInstaller" htmlfile="ChannelInstaller-id272391.html" nedfile="World/ChannelInstaller.ned" comment="//&#10;// Replaces channel objects in the network.&#10;//&#10;// This module is a temporary solution until the NED infrastructure&#10;// gets extended to accomodate channel classes.&#10;//&#10;"/>
  <tag type="simple-module" name="CircleMobility" htmlfile="CircleMobility-id226084.html" nedfile="Mobility/CircleMobility.ned" comment="//&#10;// Moves the node around a circle.&#10;//&#10;// @see ChannelControl&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="ConstSpeedMobility" htmlfile="ConstSpeedMobility-id226290.html" nedfile="Mobility/ConstSpeedMobility.ned" comment="//&#10;// Controls all movement related things of a host&#10;//&#10;// ConstSpeedMobility does not use one of the standard mobility approaches.&#10;// The user can define a velocity for each Host and an update interval. If&#10;// the velocity is greater than zero (i.e. the Host is not stationary) the&#10;// ConstSpeedMobility module calculates a random target position for the Host.&#10;// Depending to the update interval and the velocity it calculates the number of&#10;// steps to reach the destination and the step-size. Every update interval&#10;// ConstSpeedMobility calculates the new position on its way to the target&#10;// position and updates the display. Once the target position is reached&#10;// ConstSpeedMobility calculates a new target position.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @see ChannelControl&#10;// @author Steffen Sroka, Marc Loebbers, Daniel Willkomm&#10;//&#10;"/>
  <tag type="simple-module" name="Daemon" htmlfile="Daemon-id235711.html" nedfile="Network/Quagga/Daemon.ned" comment=""/>
  <tag type="simple-module" name="Decider80211" htmlfile="Decider80211-id251628.html" nedfile="NetworkInterfaces/MF80211/phyLayer/decider/Decider80211.ned" comment="//&#10;// Decider module of the 802.11 modules&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="DropTailQoSQueue" htmlfile="DropTailQoSQueue-id235904.html" nedfile="Network/Queue/DropTailQoSQueue.ned" comment="//&#10;// Drop-tail queue with QoS support, to be used in network interfaces.&#10;// Performs priority queueing.&#10;// Conforms to the OutputQueue interface.&#10;//&#10;"/>
  <tag type="simple-module" name="DropTailQueue" htmlfile="DropTailQueue-id235937.html" nedfile="Network/Queue/DropTailQueue.ned" comment="//&#10;// Drop-tail queue, to be used in network interfaces.&#10;// Conforms to the OutputQueue interface.&#10;//&#10;"/>
  <tag type="simple-module" name="Dummy" htmlfile="Dummy-id228968.html" nedfile="Network/Extras/Dummy.ned" comment="//&#10;// Implementation of a failed router. Does nothing and simply discards any&#10;// incoming messages. &#10;//&#10;"/>
  <tag type="simple-module" name="ErrAndCollDecider" htmlfile="ErrAndCollDecider-id251732.html" nedfile="NetworkInterfaces/MF80211/phyLayer/decider/ErrAndCollDecider.ned" comment="//&#10;// Decider module to use with digital channel modules like GilbertElliotSnr&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="ErrorHandling" htmlfile="ErrorHandling-id230735.html" nedfile="Network/IPv4/ErrorHandling.ned" comment="//&#10;// Handles error notifications that arrive from other protocol modules.&#10;//&#10;// Errors arrive in messages; this implementation just prints a report&#10;// and discards the message.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherAppCli" htmlfile="EtherAppCli-id204767.html" nedfile="Applications/Ethernet/EtherAppCli.ned" comment="//&#10;// Simple traffic generator for the Ethernet model and the 802.11 model;&#10;// generally any L2 model that accepts Ieee80211Ctrl control info&#10;// on the packets. It generates EtherAppReq packets. It should be connected&#10;// directly to EtherLLC or a Ieee802NicXXX module.&#10;//&#10;// Destination may be given with OMNeT++ path name or MAC address.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherAppSrv" htmlfile="EtherAppSrv-id204484.html" nedfile="Applications/Ethernet/EtherAppSrv.ned" comment="//&#10;// Server side of the EtherCli model -- generates EtherAppResp packets&#10;// with the number of bytes requested by the client in EtherAppReq.&#10;// It should be connected directly to EtherLLC or a Ieee802NicXXX module.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherBus" htmlfile="EtherBus-id240678.html" nedfile="NetworkInterfaces/Ethernet/EtherBus.ned" comment="//&#10;// A generic bus model.&#10;//&#10;// in[i], out[i] gate pairs represent taps. Messages arriving on a tap&#10;// travel on the bus on both directions, and copies of it are sent out&#10;// on every other tap after delays proportional to their distances.&#10;//&#10;// Tap connections should have zero delays and zero data rates!&#10;//&#10;// Messages are not interpreted by the bus model in any way, thus the bus&#10;// model is not specific to Ethernet in any way. Messages may&#10;// represent anything, from the beginning of a frame transmission to&#10;// end (or abortion) of transmission.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherEncap" htmlfile="EtherEncap-id241164.html" nedfile="NetworkInterfaces/Ethernet/EtherEncap.ned" comment="//&#10;// Performs Ethernet II encapsulation/decapsulation.&#10;//&#10;// Expected environment:&#10;// - lowerLayerIn, lowerLayerOut gates should be connected to Ethernet EtherMAC&#10;// - upperLayerIn, upperLayerOut gates should be connected to higher layer&#10;//   protocol or application&#10;//&#10;// Functionality:&#10;// - packets coming from upper layers will be encapsulated in EthernetIIFrame&#10;//   and sent to MAC. EtherType is taken from the Ieee802Ctrl structure attached&#10;//   to the message as control info (see setControlInfo(), controlInfo()&#10;//   methods). Src address will be filled in by EtherMAC.&#10;// - also accepts SENDPAUSE command (message kind=IEEE802CTRL_SENDPAUSE) from&#10;//   higher layer: send PAUSE frame, as described in&#10;//   &lt;a href=&quot;ether-pause.html&quot;&gt;PAUSE frames&lt;/a&gt;.&#10;// - Ethernet frames arriving from MAC will be decapsulated, and sent up to the&#10;//   higher layers. Accepts EtherFrameWithLLC and EtherFrameWithSNAP too.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherHub" htmlfile="EtherHub-id241079.html" nedfile="NetworkInterfaces/Ethernet/EtherHub.ned" comment="//&#10;// A generic wiring hub model.&#10;//&#10;// in[i], out[i] gate pairs represent ports. Messages arriving on a port&#10;// are broadcast to every other port.&#10;//&#10;// The connections should have data rate set to zero. Cable lengths&#10;// should be reflected in the delays of the connections.&#10;//&#10;// Messages are not interpreted by the hub model in any way, thus the hub&#10;// model is not specific to Ethernet in any way. Messages may&#10;// represent anything, from the beginning of a frame transmission to&#10;// end (or abortion) of transmission.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherLLC" htmlfile="EtherLLC-id240022.html" nedfile="NetworkInterfaces/Ethernet/EtherLLC.ned" comment="//&#10;// Provides Ethernet 802.3 encapsulation/decapsulation and dispatching&#10;// to the appropriate higher layer by DSAP values.&#10;//&#10;// Expected environment:&#10;// - lowerLayerIn, lowerLayerOut gates should be connected&#10;//   to Ethernet EtherMAC&#10;// - upperLayerIn[], upperLayerOut[] gates should be connected to&#10;//   higher layer protocols or applications&#10;//&#10;// Functionality:&#10;//&#10;// Processes commands received from upper layers, as described in&#10;// &lt;a href=&quot;llc-app.html&quot;&gt;Communication between LLC and higher layers&lt;/a&gt;.&#10;// The following commands are supported:&#10;// - IEEE802CTRL_DATA: send a frame.&#10;//   Encapsulates packet into EtherFrameWithLLC. This includes assigning&#10;//   dest address, ssap and dsap from the Ieee802Ctrl structure acompanying&#10;//   the message. Src address will be filled in by EtherMAC.&#10;// - IEEE802CTRL_REGISTER_DSAP: register application in LLC, as described in&#10;//   &lt;a href=&quot;appreg.html&quot;&gt;Application registration&lt;/a&gt;.&#10;// - IEEE802CTRL_DEREGISTER_DSAP: deregister application, as described in&#10;//   &lt;a href=&quot;appreg.html&quot;&gt;Application registration&lt;/a&gt;.&#10;// - IEEE802CTRL_SENDPAUSE: send PAUSE frame, as described in&#10;//   &lt;a href=&quot;ether-pause.html&quot;&gt;PAUSE frames&lt;/a&gt;.&#10;//&#10;// Processing of packets received from the lower layers:&#10;// - decapsulate frames received from EtherMAC&#10;// - sends received frames to corresponding application, based on dsap.&#10;// - only servicetype=0 is implemented (connectionless)&#10;// - reception of non-EtherFrameWithLLC objects (e.g. EthernetIIFrame,&#10;//   EtherFrameWithSNAP) will cause a runtime error.&#10;//&#10;"/>
  <tag type="simple-module" name="EtherMAC" htmlfile="EtherMAC-id240352.html" nedfile="NetworkInterfaces/Ethernet/EtherMAC.ned" comment="//&#10;// Ethernet MAC layer. MAC performs transmission and reception of frames.&#10;// Doesn't do encapsulation/decapsulation; see EtherLLC and EtherEncap for&#10;// that.&#10;//&#10;// Supported variations:&#10;// - 10Mb Ethernet bus or twisted pair&#10;// - 100Mb Ethernet duplex or half-duplex&#10;// - 1Gb Ethernet&#10;//&#10;// Supports all three Ethernet frame types. (It handles EtherFrame message class;&#10;// specific frame classes (Ethernet-II, IEEE 802.3) are subclassed from that one.)&#10;// RAW mode (only used by the IPX protocol) is not supported.&#10;//&#10;// Expected environment:&#10;// - physIn and physOut should be connected to the &quot;network&quot;&#10;// - upperLayerIn and upperLayerOut are usually connected to EtherLLC (in hosts)&#10;//   or MACRelayUnitPP (in a switch)&#10;//&#10;// &lt;b&gt;Operation&lt;/b&gt;&#10;//&#10;// Processing of frames received from higher layers:&#10;// - if src address in the frame is empty, fill it out&#10;// - frames get queued up until transmission&#10;// - transmit according to the CSMA/CD protocol&#10;// - can send PAUSE message if requested by higher layers (PAUSE protocol,&#10;//   used in switches).&#10;//&#10;// Processing of frames incoming from the network:&#10;// - receive according to the CSMA/CD protocol&#10;// - CRC checking (frames with the error bit set are discarded).&#10;// - respond to PAUSE frames&#10;// - in promiscuous mode, pass up all received frames;&#10;//   otherwise, only frames with matching MAC addresses and&#10;//   broadcast frames are passed up.&#10;//&#10;// The module does not perform encapsulation or decapsulation of frames --&#10;// this is done by higher layers (EtherLLC or EtherEncap).&#10;//&#10;// When a frame is received from the higher layers, it must be an EtherFrame&#10;// with message kind set to ETH_FRAME, and with all protocol fields filled out&#10;// (including the destination MAC address). The source address, if left empty,&#10;// will be filled in. Then frame is queued and transmitted according&#10;// to the CSMA/CD protocol.&#10;//&#10;// Data frames received from the network are EtherFrames, with message kind set&#10;// to ETH_FRAME. They are passed to the higher layers without modification.&#10;// Also, the module properly responds to PAUSE frames, but never sends them&#10;// by itself -- however, it transmits PAUSE frames received from upper layers.&#10;// See &lt;a href=&quot;ether-pause.html&quot;&gt;PAUSE handling&lt;/a&gt; for more info.&#10;//&#10;// &lt;b&gt;Autoconfiguration&lt;/b&gt;&#10;//&#10;// A very short period at the beginning of the simulation is spent on&#10;// all EtherMAC's exchanging autoconfiguration messages, during which&#10;// the selection of transmission rate and full duplex/half duplex mode&#10;// takes place.&#10;//&#10;// For more info see &lt;a href=&quot;ether-overview.html&quot;&gt;Ethernet Model Overview&lt;/a&gt;.&#10;//&#10;// &lt;b&gt;Disabling and disconnecting&lt;/b&gt;&#10;//&#10;// If the MAC is not connected to the network (&quot;cable unplugged&quot;), it will&#10;// start up in &quot;disabled&quot; mode. A disabled MAC simply discards any messages&#10;// it receives. It is currently not supported to dynamically connect/disconnect&#10;// a MAC.&#10;//&#10;//&#10;// &lt;b&gt;Queueing&lt;/b&gt;&#10;//&#10;// In routers, MAC relies on an external queue module (see OutputQueue)&#10;// to model finite buffer, implement QoS and/or RED, and requests packets&#10;// from this external queue one-by-one.&#10;//&#10;// In hosts, no such queue is used, so MAC contains an internal&#10;// queue named txQueue to queue up packets waiting for transmission.&#10;// Conceptually, txQueue is of infinite size, but for better diagnostics&#10;// one can specify a hard limit in the txQueueLimit parameter -- if this is&#10;// exceeded, the simulation stops with an error.&#10;//&#10;//&#10;// &lt;b&gt;Physical layer messaging&lt;/b&gt;&#10;//&#10;// Please see &lt;a href=&quot;physical.html&quot;&gt;Messaging on the physical layer&lt;/a&gt;.&#10;//&#10;// &lt;b&gt;Statistics&lt;/b&gt;&#10;//&#10;// Output vectors and WATCHes:&#10;// - framesSent: number of frames sent&#10;// - framesReceivedOK: number of frames received without collision or CRC error&#10;// - bytesSent: bytes sent, including Ethernet frame fields (but excluding preamble and SFD)&#10;// - bytesReceivedOK: total bytes received, including Ethernet frame fields&#10;//   (but excluding preamble and SFD), including discarded frames (see also&#10;//   framesPassedToHL)&#10;// - droppedIfaceDown: number of frames from higher layer dropped&#10;// - droppedBitError: number of frames dropped because of bit errors&#10;// - droppedNotForUs: number of frames dropped because destination address didn't match&#10;// - framesPassedToHL: number of frames actually passed up to higher layer&#10;// - pauseFramesRcvd: number of PAUSE frames received from network&#10;// - pauseFramesSent: number of PAUSE frames sent out&#10;// - collisions: number of collisions (NOT number of collided frames!) sensed&#10;// - backoffs: number of retransmissions&#10;//&#10;// Output scalars (written in the finish() function) include the final values of&#10;// the above variables and throughput.&#10;//&#10;// @see EtherMAC2, EthernetInterface, EthernetInterface2, OutputQueue, EtherEncap, EtherLLC&#10;// @see EtherFrame, EthernetIIFrame, EtherFrameWithLLC, Ieee802Ctrl&#10;//&#10;"/>
  <tag type="simple-module" name="EtherMAC2" htmlfile="EtherMAC2-id240348.html" nedfile="NetworkInterfaces/Ethernet/EtherMAC2.ned" comment="//&#10;// Ethernet MAC which supports full duplex operation ONLY.&#10;//&#10;// Most of today's Ethernet networks are switched, and operate&#10;// in full duplex mode. Full-duplex transmission can be used for&#10;// point-to-point connections only. Since full-duplex connections&#10;// cannot be shared, collisions are eliminated. This setup eliminates&#10;// most of the need for the CSMA/CD access control mechanism because&#10;// there is no need to determine whether the connection is already&#10;// being used. This allows for a much simpler simulation model&#10;// for MAC. (In &quot;traditional&quot; Ethernet simulations, most of the code&#10;// deals with the shared medium and the CSMA/CD mechanism.)&#10;// EtherMAC2 implements Ethernet without shared medium and CSMA/CD.&#10;// (If you need half-duplex operation, see EtherMAC which is for a full-blown&#10;// and therefore more complicated Ethernet MAC model.)&#10;//&#10;// EtherMAC2 performs transmission and reception of frames.&#10;// It does not do encapsulation/decapsulation; see EtherLLC and EtherEncap&#10;// for that.&#10;//&#10;// Supported variations:&#10;// - 100Mb Ethernet (full duplex mode)&#10;// - 1Gb Ethernet (full duplex mode)&#10;//&#10;// Supports all three Ethernet frame types. (It handles EtherFrame message class;&#10;// specific frame classes (Ethernet-II, IEEE 802.3) are subclassed from that one.)&#10;// RAW mode (only used by the IPX protocol) is not supported.&#10;//&#10;// Expected environment:&#10;// - physIn and physOut should be connected to the &quot;network&quot;&#10;// - upperLayerIn and upperLayerOut are usually connected to EtherLLC (in hosts)&#10;//   or MACRelayUnitPP (in a switch)&#10;//&#10;// &lt;b&gt;Operation&lt;/b&gt;&#10;//&#10;// Processing of frames received from higher layers:&#10;// - if src address in the frame is empty, fill it out&#10;// - frames get queued up until transmission&#10;// - transmit according to the CSMA/CD protocol&#10;// - can send PAUSE message if requested by higher layers (PAUSE protocol,&#10;//   used in switches).&#10;//&#10;// Processing of frames incoming from the network:&#10;// - receive according to the CSMA/CD protocol&#10;// - CRC checking (frames with the error bit set are discarded).&#10;// - respond to PAUSE frames&#10;// - in promiscuous mode, pass up all received frames;&#10;//   otherwise, only frames with matching MAC addresses and&#10;//   broadcast frames are passed up.&#10;//&#10;// The module does not perform encapsulation or decapsulation of frames --&#10;// this is done by higher layers (EtherLLC or EtherEncap).&#10;//&#10;// When a frame is received from the higher layers, it must be an EtherFrame&#10;// with message kind set to ETH_FRAME, and with all protocol fields filled out&#10;// (including the destination MAC address). The source address, if left empty,&#10;// will be filled in. Then frame is queued and transmitted according&#10;// to the CSMA/CD protocol.&#10;//&#10;// Data frames received from the network are EtherFrames, with message kind set&#10;// to ETH_FRAME. They are passed to the higher layers without modification.&#10;// Also, the module properly responds to PAUSE frames, but never sends them&#10;// by itself -- however, it transmits PAUSE frames received from upper layers.&#10;// See &lt;a href=&quot;ether-pause.html&quot;&gt;PAUSE handling&lt;/a&gt; for more info.&#10;//&#10;// &lt;b&gt;Autoconfiguration&lt;/b&gt;&#10;//&#10;// EtherMAC2 does NOT include autoconfiguration. \Link speed is taken from&#10;// the &lt;tt&gt;datarate&lt;/tt&gt; attribute of the connection instead of module parameters&#10;// or autoconfiguration.&#10;//&#10;// For more info see &lt;a href=&quot;ether-overview.html&quot;&gt;Ethernet Model Overview&lt;/a&gt;.&#10;//&#10;// &lt;b&gt;Disabling and disconnecting&lt;/b&gt;&#10;//&#10;// If the MAC is not connected to the network (&quot;\cable unplugged&quot;), it will&#10;// start up in &quot;disabled&quot; mode. A disabled MAC simply discards any messages&#10;// it receives. It is currently not supported to dynamically connect/disconnect&#10;// a MAC.&#10;//&#10;//&#10;// &lt;b&gt;Queueing&lt;/b&gt;&#10;//&#10;// In routers, MAC relies on an external queue module (see OutputQueue)&#10;// to model finite buffer, implement QoS and/or RED, and requests packets&#10;// from this external queue one-by-one.&#10;//&#10;// In hosts, no such queue is used, so MAC contains an internal&#10;// queue named txQueue to queue up packets waiting for transmission.&#10;// Conceptually, txQueue is of infinite size, but for better diagnostics&#10;// one can specify a hard limit in the txQueueLimit parameter -- if this is&#10;// exceeded, the simulation stops with an error.&#10;//&#10;//&#10;// &lt;b&gt;Physical layer messaging&lt;/b&gt;&#10;//&#10;// Please see &lt;a href=&quot;physical.html&quot;&gt;Messaging on the physical layer&lt;/a&gt;.&#10;//&#10;// &lt;b&gt;Statistics&lt;/b&gt;&#10;//&#10;// Output vectors and WATCHes:&#10;// - framesSent: number of frames sent&#10;// - framesReceivedOK: number of frames received without collision or CRC error&#10;// - bytesSent: bytes sent, including Ethernet frame fields (but excluding preamble and SFD)&#10;// - bytesReceivedOK: total bytes received, including Ethernet frame fields&#10;//   (but excluding preamble and SFD), including discarded frames (see also&#10;//   framesPassedToHL)&#10;// - droppedIfaceDown: number of frames from higher layer dropped&#10;// - droppedBitError: number of frames dropped because of bit errors&#10;// - droppedNotForUs: number of frames dropped because destination address didn't match&#10;// - framesPassedToHL: number of frames actually passed up to higher layer&#10;// - pauseFramesRcvd: number of PAUSE frames received from network&#10;// - pauseFramesSent: number of PAUSE frames sent out&#10;// - collisions: number of collisions (NOT number of collided frames!) sensed&#10;// - backoffs: number of retransmissions&#10;//&#10;// Output scalars (written in the finish() function) include the final values of&#10;// the above variables and throughput.&#10;//&#10;// @see EthernetInterface, EthernetInterface, OutputQueue, EtherEncap, EtherLLC&#10;// @see EtherFrame, EthernetIIFrame, EtherFrameWithLLC, Ieee802Ctrl&#10;//&#10;"/>
  <tag type="simple-module" name="FailureManager" htmlfile="FailureManager-id229111.html" nedfile="Network/Extras/FailureManager.ned" comment="//&#10;// Module for managing node failure and recovery in the network. If used,&#10;// it should have exactly one instance in the whole network.&#10;//&#10;// FailureManager does not send or receive messages, and has no parameters&#10;// either. Instead, it is invoked from ScenarioManager scripts, for example:&#10;//&#10;// &lt;pre&gt;&lt;nohtml&gt;&#10;// &lt;scenario&gt;&#10;//   &lt;at t=&quot;2&quot;&gt;&#10;//     &lt;shutdown module=&quot;failureManager&quot; target=&quot;LSR2&quot;/&gt;&#10;//   &lt;/at&gt;&#10;//   &lt;at t=&quot;10&quot;&gt;&#10;//     &lt;startup module=&quot;failureManager&quot; target=&quot;LSR2&quot;/&gt;&#10;//   &lt;/at&gt;&#10;// &lt;/scenario&gt;&#10;// &lt;/nohtml&gt;&lt;/pre&gt;&#10;//&#10;// It is currently only used with MPLS simulations, and supports the following&#10;// commands:&#10;//&#10;// - &lt;code&gt;shutdown&lt;/code&gt;: replaces a router module named by the &lt;tt&gt;target&lt;/tt&gt; attribute&#10;//   with another module that represents a failed router. It currently replaces&#10;//   RSVP_LSR with RSVP_FAILED, LDP_LSR with LDP_FAILED, and QuaggaRouter with&#10;//   FailedRouter.&#10;// - &lt;code&gt;startup&lt;/code&gt;: the inverse of &lt;tt&gt;shutdown&lt;/tt&gt;: replaces a &lt;i&gt;failed&lt;/i&gt;&#10;//   router model named by the &lt;tt&gt;target&lt;/tt&gt; attribute with an operational host/router&#10;//   module type.&#10;//&#10;// The operation of FailureManager is likely to get refined and generalized in next&#10;// versions.&#10;//&#10;"/>
  <tag type="simple-module" name="FlatNetworkConfigurator" htmlfile="FlatNetworkConfigurator-id227631.html" nedfile="Network/AutoRouting/FlatNetworkConfigurator.ned" comment="//&#10;// Configures \IP addresses and routing tables for a &quot;flat&quot; network,&#10;// &quot;flat&quot; meaning that all hosts and routers will have the same&#10;// network address and will only differ in the host part.&#10;//&#10;// This module does't connect to any other modules (it has no gates),&#10;// and should have only one instance in the whole model. The module&#10;// will only run once, at the beginning of the simulation.&#10;// When it runs, it will:&#10;//&#10;//   -#  assign \IP addresses to hosts and routers. All hosts and&#10;//       routers will be in the same network (same network address).&#10;//       For simplicity, it will assign the same address to all interfaces&#10;//       of a router;&#10;//   -#  then it'll discover the topology of the network (using OMNeT++'s&#10;//       cTopology class), and calculate shortest paths;&#10;//   -#  finally, it will add routes which correspond to the shortest&#10;//       paths to the routing tables (see RoutingTable::addRoutingEntry()).&#10;//&#10;// How does it know which modules are routers, hosts, et.c that need to&#10;// be configured, and what is the network topology? The configurator&#10;// picks all modules of types listed in the moduleTypes parameter and&#10;// their connections, and builds a graph from it. Then it runs Dijstra's&#10;// shortest path algorithm on it, and configures all modules which are&#10;// \IP nodes, that is, not listed in the nonIPModuleTypes parameter.&#10;//&#10;// It is assumed that the routing table (RoutingTable module) is the&#10;// &quot;routingTable&quot; or &quot;networkLayer.routingTable&quot; submodule in all hosts&#10;// and routers.&#10;//&#10;// To avoid interference with the above algorithm, it's recommended that&#10;// no host or router should have its address set explicitly, and&#10;// no routes are set up manually. Practically, routing files (.irt, .mrt)&#10;// should be missing or empty.&#10;//&#10;// All the above takes place in initialization stage 2. (In stage 0,&#10;// interfaces register themselves in the InterfaceTable modules, and&#10;// in stage 1, routing files are read.)&#10;//&#10;"/>
  <tag type="simple-module" name="FlatNetworkConfigurator6" htmlfile="FlatNetworkConfigurator6-id227802.html" nedfile="Network/AutoRouting/FlatNetworkConfigurator6.ned" comment="//&#10;// Configures \IPv6 addresses and routing tables for a &quot;flat&quot; network,&#10;// &quot;flat&quot; meaning that all hosts and routers will have the same&#10;// network address and will only differ in the host part.&#10;//&#10;// FIXME: add documentation!&#10;//&#10;// @see FlatNetworkConfigurator&#10;//&#10;"/>
  <tag type="simple-module" name="GenericRadio" htmlfile="GenericRadio-id254136.html" nedfile="NetworkInterfaces/Radio/GenericRadio.ned" comment="//&#10;// Generic radio module. The implementation is largely based on the&#10;// Mobility Framework's SnrEval and Decider modules.&#10;//&#10;// @see Radio&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="GilbertElliotSnr" htmlfile="GilbertElliotSnr-id251940.html" nedfile="NetworkInterfaces/MF80211/phyLayer/snrEval/GilbertElliotSnr.ned" comment="//&#10;// Gilbert-Elliot signal-noise evaluator&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="ICMP" htmlfile="ICMP-id230662.html" nedfile="Network/IPv4/ICMP.ned" comment="//&#10;// ICMP implementation&#10;//&#10;// Receive ICMP message from localDeliver and process it:&#10;//   - echo/timestamp reply: strip ICMP header and send to pingOut&#10;//   - echo/timestamp request: create reply and send to IPSend&#10;//   - destination unreachable: ignore/send to IPRouting (static)?&#10;//   - time exceeded: ignore ?&#10;//   - parameter problem: ignore ?&#10;//   - redirect ?&#10;//#FIXME question marks above...&#10;//&#10;// Receive echo/timestamp message from pingIn: encapsulate in ICMP header&#10;// and send to IPSend&#10;//&#10;// author: Jochen Reber&#10;// date: 2.5.00, 9.5.00, 20.5.00, 9.6.00&#10;// redesign: Andras Varga 1.3.2004&#10;//&#10;"/>
  <tag type="simple-module" name="ICMPv6" htmlfile="ICMPv6-id229107.html" nedfile="Network/ICMPv6/ICMPv6.ned" comment="//&#10;// ICMPv6 implementation.&#10;//&#10;// To send ICMPv6 Echo Request, send any message to port pingIn with IPv6ControlInfo&#10;// attached. The message will be used as ping payload (encapsulated into an ICMPv6Message).&#10;// When ICMPv6 Echo Reply is received, the payload message will be sent to pingOut.&#10;//&#10;// @see IPv6, RoutingTable6, IPv6NeighbourDiscovery&#10;//#FIXME gate descriptions needed...&#10;//&#10;"/>
  <tag type="simple-module" name="IP" htmlfile="IP-id231134.html" nedfile="Network/IPv4/IP.ned" comment="//&#10;// Implements the \IP protocol. The protocol header is represented&#10;// by the IPDatagram message class.&#10;//&#10;// &lt;b&gt;Interfacing with higher layer protocols&lt;/b&gt;&#10;//&#10;// To send a packet over IP from a higher layer protocol, the module should&#10;// fill in an IPControlInfo object, attach it to the packet with cMessage's&#10;// setControlInfo() method, the send it to the IP module.&#10;//&#10;// When IP sends up a packet to a higher layer protocol, it will also attach&#10;// an IPControlInfo to the packet, with the source and destination IP address,&#10;// etc. of the IP datagram in which the packet arrived.&#10;//&#10;// IP can serve several higher-layer protocols. When delivering packets&#10;// to them, the output gate is determined from the Protocol field in the&#10;// \IP header. The protocol-to-gateindex mapping must be given in the&#10;// protocolMapping string parameter, in the following format:&#10;// &lt;pre&gt;&#10;// protocolnumber:gateindex, protocolnumber:gateindex, ...&#10;// &lt;/pre&gt;&#10;//&#10;// The recommended setting is:&#10;// - \TCP (6) : 0&#10;// - \UDP (17) : 1&#10;// - \ICMP (1) : 2&#10;// - \IGMP (2) : 3&#10;// - \RSVP (46) : 4&#10;//&#10;// That is, &lt;tt&gt;protocolMapping=&quot;6:0,17:1,1:2,2:3,46:4&quot;&lt;/tt&gt;&#10;//&#10;// &lt;b&gt;Routing and interfacing with lower layers&lt;/b&gt;&#10;//&#10;// The routing table is stored in the module RoutingTable. When a datagram&#10;// needs to be routed, IP queries RoutingTable for the output interface&#10;// (or &quot;port&quot;) and next hop address of the packet. This is done by directly&#10;// calling C++ methods (such as findBestMatchingRoute(destAddress)) of RoutingTable.&#10;// No message exchange with RoutingTable takes place.&#10;//&#10;// A routed datagram will be sent to the queueOut gate, with an&#10;// IPRoutingDecision control info object attached which contains&#10;// next hop address and interface number. queueOut is expected to be&#10;// connected to ARP.&#10;//&#10;// Routing protocol implementations (e.g. OSPF and ISIS) can also query&#10;// and manipulate the route table by calling RoutingTable's methods in C++.&#10;//&#10;// &lt;b&gt;Performance model, QoS&lt;/b&gt;&#10;//&#10;// In the current form, IP contains a FIFO which queues up \IP datagrams;&#10;// datagrams are processed in order. The processing time is determined by the&#10;// procDelay module parameter.&#10;//&#10;// The current performance model comes from the QueueBase C++ base class.&#10;// If you need a more sophisticated performance model, you may change the&#10;// module implementation (the IP class), and: (1) override the startService()&#10;// method which determines processing time for a packet, or (2) use a&#10;// different base class.&#10;//&#10;// @see RoutingTable, IPControlInfo, IPRoutingDecision, ARP&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="IPTrafGen" htmlfile="IPTrafGen-id221937.html" nedfile="Applications/Generic/IPTrafGen.ned" comment="//&#10;// Sends IP or IPv6 datagrams to the given address at the given interval.&#10;// The interval can be a constant or a random value (e.g. exponential(1)).&#10;// If the destAddresses parameter contains more than one address, one&#10;// of them is randomly for each packet. An address may be given in the&#10;// dotted decimal notation (or, for IPv6, in the usual notation with colons),&#10;// or with the module name. (The IPAddressResolver class is used to resolve &#10;// the address.) To disable the model, set destAddresses to &quot;&quot;.&#10;//&#10;// The peer can be IPTrafSink or another IPTrafGen (it handles received packets&#10;// exactly like IPTrafSink).&#10;//&#10;"/>
  <tag type="simple-module" name="IPTrafSink" htmlfile="IPTrafSink-id223660.html" nedfile="Applications/Generic/IPTrafGen.ned" comment="//&#10;// Consumes and prints packets received from the IP module.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;"/>
  <tag type="simple-module" name="IPTrafficGenerator" htmlfile="IPTrafficGenerator-id223690.html" nedfile="Applications/Generic/IPTrafficGenerator.ned" comment="//&#10;// Prototype for modules that generate traffic directly over IP.&#10;//&#10;// @see IPTrafGen, IPTrafSink&#10;//&#10;"/>
  <tag type="simple-module" name="IPv6" htmlfile="IPv6-id232445.html" nedfile="Network/IPv6/IPv6.ned" comment="//&#10;// Implements the \IPv6 protocol.&#10;//&#10;// An overview of the \IPv6 implementation in the INET Framework is&#10;// provided &lt;a href=&quot;ipv6overview.html&quot;&gt;here&lt;/a&gt;.&#10;//&#10;// The \IPv6 protocol header is represented by the IPv6Datagram message class.&#10;//&#10;// &lt;b&gt;Interfacing with higher layer protocols&lt;/b&gt;&#10;//&#10;// To send a packet over \IPv6 from a higher layer protocol, the module should&#10;// fill in an IPv6ControlInfo object, attach it to the packet with cMessage's&#10;// setControlInfo() method, the send it to the IPv6 module.&#10;//&#10;// When IPv6 sends up a packet to a higher layer protocol, it will also attach&#10;// an IPv6ControlInfo to the packet, with the source and destination \IPv6 address,&#10;// etc. of the \IPv6 datagram in which the packet arrived.&#10;//&#10;// IPv6 can serve several higher-layer protocols. When delivering packets&#10;// to them, the output gate is determined from the Protocol field in the&#10;// \IPv6 datagram class. The protocol-to-gateindex mapping must be given&#10;// in the protocolMapping string parameter, in the following format:&#10;// &lt;pre&gt;&#10;// protocolnumber:gateindex, protocolnumber:gateindex, ...&#10;// &lt;/pre&gt;&#10;//&#10;// The recommended setting is:&#10;// - \TCP (6) : 0&#10;// - \UDP (17) : 1&#10;// - \RSVP (46) : 2&#10;// - \ICMPv6 (89) : 3&#10;//&#10;// That is, &lt;tt&gt;protocolMapping=&quot;6:0,17:1,46:2,89:3&quot;&lt;/tt&gt;&#10;//&#10;// &lt;b&gt;Routing and interfacing with lower layers&lt;/b&gt;&#10;//&#10;// The routing table is stored in the module RoutingTable6. When a datagram&#10;// needs to be routed, \IPv6 queries RoutingTable6 for the output interface&#10;// (or &quot;port&quot;) and next hop address of the packet. This is done by directly&#10;// calling C++ methods of RoutingTable6. No message exchange with RoutingTable6&#10;// takes place.&#10;//&#10;//#FIXME TBD describe operation&#10;//&#10;// Routing protocol implementations can also query and manipulate the route table&#10;// by calling RoutingTable6's methods in C++.&#10;//&#10;// &lt;b&gt;Performance model, QoS&lt;/b&gt;&#10;//&#10;// In the current form, IPv6 contains a FIFO which queues up \IPv6 datagrams;&#10;// datagrams are processed in order. The processing time is determined by the&#10;// procDelay module parameter.&#10;//&#10;// @see RoutingTable6, IPv6ControlInfo, IPv6NeighbourDiscovery, ICMPv6&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="IPv6ErrorHandling" htmlfile="IPv6ErrorHandling-id232510.html" nedfile="Network/IPv6/IPv6ErrorHandling.ned" comment="//&#10;// Handles error notifications that arrive from other protocol modules.&#10;//&#10;// Errors arrive in messages; this implementation just prints a report&#10;// and discards the message.&#10;//&#10;// IPv6 implementation&#10;// TODO: This is just a quick fix. We should have only ONE error handling&#10;// module for both versions of IP.-WEI&#10;"/>
  <tag type="simple-module" name="IPv6NeighbourDiscovery" htmlfile="IPv6NeighbourDiscovery-id229263.html" nedfile="Network/ICMPv6/IPv6NeighbourDiscovery.ned" comment="//&#10;// Implements \IPv6 Neighbour Discovery.&#10;//&#10;// An overview of the \IPv6 implementation in the INET Framework is&#10;// provided &lt;a href=&quot;ipv6overview.html&quot;&gt;here&lt;/a&gt;.&#10;//&#10;// @see IPv6, RoutingTable6, ICMPv6&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211AgentSTA" htmlfile="Ieee80211AgentSTA-id246827.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211AgentSTA.ned" comment="//&#10;// Used in 802.11 infrastructure mode: in a station (STA), this module&#10;// controls channel scanning, association and handovers, by sending commands&#10;// (e.g. Ieee80211Prim_ScanRequest) to the management module (Ieee80211MgmtSTA).&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211Mac" htmlfile="Ieee80211Mac-id246064.html" nedfile="NetworkInterfaces/Ieee80211/Mac/Ieee80211Mac.ned" comment="//&#10;// Implementation of the 802.11b MAC protocol. This module is intended&#10;// to be used in combination with the Ieee80211Radio module as the physical&#10;// layer. (The SnrEval80211 and Decider80211 modules should also work if&#10;// per-packet bitrate setting gets implemented.)&#10;//&#10;// Encapsulation/decapsulation must be done in the upper layers. (It is&#10;// typically in the 802.11 management module, see in Ieee80211Nic).&#10;// The base class for 802.11 frame messages is Ieee80211Frame, but this&#10;// module expects Ieee80211DataOrMgmtFrame (a subclass) from upper layers&#10;// (the management module). This module will assign the transmitter address&#10;// (address 2) and the frame sequence number/fragment number fields in the&#10;// frames; all other fields must already be filled when this module gets&#10;// the frame for transmission.&#10;//&#10;// The module has an internal queue, but usually it is to be used with an&#10;// external passive queue module (its name should be given in the queueModule&#10;// parameter; specifying &quot;&quot; causes the internal queue to be used). The passive&#10;// queue module is a simple module whose C++ class implements the IPassiveQueue&#10;// interface.&#10;//&#10;// &lt;b&gt;Limitations&lt;/b&gt;&#10;//&#10;// The following features not supported: 1) fragmentation, 2) power management,&#10;// 3) polling (PCF). Physical layer algorithms such as frequency hopping and &#10;// direct sequence spread spectrum are not modelled directly.&#10;//&#10;// Fields related to the above unsupported features are omitted from&#10;// management frame formats as well (for example, FH/DS/CF parameter sets,&#10;// beacon/probe timestamp which is related to physical layer synchronization,&#10;// listen interval which is related to power management, capability information&#10;// which is related to PCF and other non-modelled features).&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211Mgmt" htmlfile="Ieee80211Mgmt-id246977.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211Mgmt.ned" comment="//&#10;// This is not a concrete module type, but a prototype for all IEEE 802.11&#10;// management module types. It exists to specify what gates a management&#10;// module should have in order to be usable within Ieee80211Nic.&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211MgmtAP" htmlfile="Ieee80211MgmtAP-id247223.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtAP.ned" comment="//&#10;// Used in 802.11 infrastructure mode: handles management frames for&#10;// an access point (AP). It relies on a connected Ieee80211Mac for actual&#10;// reception and transmission of frames.&#10;//&#10;// When simulating an AP that has other (Ethernet or wireless) interfaces&#10;// as well, this module can be connected to a MACRelayUnit which performs&#10;// bridging of Ethernet frames. This module will perform conversion from/to&#10;// EtherFrame for MACRelayUnit.&#10;//&#10;// This module never switches channels, that is, it will operate on the channel&#10;// the physical layer is configured for (see channelNumber in Ieee80211Radio).&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211MgmtAPSimplified" htmlfile="Ieee80211MgmtAPSimplified-id247334.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtAPSimplified.ned" comment="//&#10;// Used in 802.11 infrastructure mode: handles management frames for&#10;// an access point (AP). It relies on a connected Ieee80211Mac for actual&#10;// reception and transmission of frames.&#10;//&#10;// This management module variant does not implement beacons, probes,&#10;// authentication and association -- it simply treats all stations&#10;// as associated all the time. This also means that you cannot use this&#10;// module in a simulation that involves handovers; for that you need&#10;// to use the full version, Ieee80211MgmtAP.&#10;//&#10;// When simulating an AP that has other (Ethernet or wireless) interfaces&#10;// as well, this module can be connected to a MACRelayUnit which performs&#10;// bridging of Ethernet frames. This module will perform conversion from/to&#10;// EtherFrame for MACRelayUnit.&#10;//&#10;// This module never switches channels, that is, it will operate on the channel&#10;// the physical layer is configured for (see channelNumber in Ieee80211Radio).&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211MgmtAdhoc" htmlfile="Ieee80211MgmtAdhoc-id247016.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtAdhoc.ned" comment="//&#10;// 802.11 management module used for ad-hoc mode.&#10;// Relies on the MAC layer (Ieee80211Mac) for reception and transmission of frames.&#10;//&#10;// This implementation never sends control or management frames, and discards&#10;// any such frame received. Distributed beacon generation is not modelled.&#10;// Only data frames are understood or sent at any time.&#10;//&#10;// This module never switches channels, that is, it will operate on the channel&#10;// the physical layer is configured for (see channelNumber in Ieee80211Radio).&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211MgmtSTA" htmlfile="Ieee80211MgmtSTA-id247429.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtSTA.ned" comment="//&#10;// Used in 802.11 infrastructure mode: handles management frames for a station (STA).&#10;//&#10;// Relies on the MAC layer (Ieee80211Mac) for reception and transmission of frames.&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211MgmtSTASimplified" htmlfile="Ieee80211MgmtSTASimplified-id247554.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtSTASimplified.ned" comment="//&#10;// Used in 802.11 infrastructure mode: handles management frames for a station (STA).&#10;// Relies on the MAC layer (Ieee80211Mac) for reception and transmission of frames.&#10;//&#10;// This variant is a very simplistic: the AP address and channel is preconfigured,&#10;// there is no scanning, authentication or association. Only data frames are&#10;// understood or sent at any time.&#10;//&#10;// This module never switches channels, that is, it will operate on the channel&#10;// the physical layer is configured for (see channelNumber in Ieee80211Radio).&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Ieee80211Radio" htmlfile="Ieee80211Radio-id254399.html" nedfile="NetworkInterfaces/Radio/Ieee80211Radio.ned" comment="//&#10;// Physical layer for the IEEE 802.11 models. Its external interface&#10;// (including gates and how it communicates with other modules)&#10;// is the same as the Radio module's.&#10;//&#10;// The implementation is largely based on the Mobility Framework's&#10;// SnrEval80211 and Decider80211 modules.&#10;//&#10;// @see Radio&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="InterfaceTable" htmlfile="InterfaceTable-id227840.html" nedfile="Network/Contract/InterfaceTable.ned" comment="//&#10;// Keeps the table of network interfaces.&#10;//&#10;// Interfaces are dynamically registered by the corresponding L2 modules, e.g.&#10;// PPPInterface. In addition to registered interfaces, a loopback interface&#10;// will also be created. This table only contains protocol-independent&#10;// properties of interfaces -- IP or IPv6 specific per-interface data&#10;// (addresses etc) are kept in RoutingTable and RoutingTable6.&#10;//&#10;// This module has no gates; all functionality can be accessed via member&#10;// functions of the C++ module class. For detailed info, please see the C++&#10;// documentation of the class (Doxygen).&#10;//&#10;// @author: Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="Join" htmlfile="Join-id225327.html" nedfile="Base/Join.ned" comment="//&#10;// Joins multiple input streams into a single output stream.&#10;//&#10;"/>
  <tag type="simple-module" name="LDP" htmlfile="LDP-id233136.html" nedfile="Network/LDP/LDP.ned" comment="//&#10;// Handles and processes LDP messages.&#10;//&#10;// The LDP protocol is used by one LSR (Label Switched \Router) to inform&#10;// another LSR of the label bindings it has made. The LSR uses this protocol&#10;// to establish label switched paths through a network by mapping network layer&#10;// routing information directly to data-link layer switched paths.&#10;//&#10;// Operations&#10;//&#10;// All LDP message types are subclassed from LDPPacket, and include&#10;// LDPHello, LDPNotify, LDPLabelRequest, LDPIni and LDPAddress.&#10;//&#10;// Message processing in the LDP module is explained in&#10;// &lt;a href=&quot;ldp-processing.html&quot;&gt;LDP Message Processing&lt;/a&gt;&#10;//&#10;// @author Andras Varga, Vojta Janota&#10;//&#10;"/>
  <tag type="simple-module" name="LIBTable" htmlfile="LIBTable-id233773.html" nedfile="Network/MPLS/LIBTable.ned" comment="//&#10;// Stores the LIB (Label Information Base), accessed by MPLS and its &#10;// associated control protocols (RSVP, LDP) via direct C++ method calls.&#10;//&#10;"/>
  <tag type="simple-module" name="LinearMobility" htmlfile="LinearMobility-id226428.html" nedfile="Mobility/LinearMobility.ned" comment="//&#10;// This is a linear mobility model with speed, angle and acceleration parameters.&#10;// Angle only changes when the mobile node hits a wall: then it reflects&#10;// off the wall at the same angle.&#10;//&#10;// @see ChannelControl&#10;// @author Emin Ilker Cetinbas&#10;//&#10;"/>
  <tag type="simple-module" name="LinkStateRouting" htmlfile="LinkStateRouting-id238439.html" nedfile="Network/TED/LinkStateRouting.ned" comment="//&#10;// This module implements a very minimalistic link state routing protcol.&#10;// Apart from the basic topology information, the current link usage&#10;// is distributed to all participants in the network (by means of flooding).&#10;//&#10;// Collaborations&#10;//&#10;// The link state database is kept in the TED module.&#10;//&#10;"/>
  <tag type="simple-module" name="MACRelayUnit" htmlfile="MACRelayUnit-id243370.html" nedfile="NetworkInterfaces/EtherSwitch/MACRelayUnit.ned" comment="//&#10;// Prototype for modules providing Ethernet switch functionality.&#10;// These modules handle the mapping between ports and MAC addresses,&#10;// and forward frames (EtherFrame) to appropriate ports.&#10;//&#10;// Functions:&#10;// - relays frames based on their dest MAC addresses (dest--&gt;port mapping)&#10;// - models finite buffer size (drops) and finite processing power (latency, queueing)&#10;//&#10;// Address caching is modeled by a fixed-size lookup table.&#10;// When the table is full, the oldest address is kicked out of the cache.&#10;//&#10;// Entries are also deleted if their age exceeds a certain limit.&#10;//&#10;// If needed, address tables can be pre-loaded from text files at the beginning&#10;// of the simulation; this controlled by the addressTableFile module parameter.&#10;//&#10;// This module is not a concrete implementation, it just defines gates and&#10;// parameters a MACRelayUnit should have. Concrete inplementations add&#10;// capacity and performance aspects to the model (number of frames processed&#10;// per second, amount of memory available in the switch, etc.)&#10;// C++ implementations can subclass from the class &lt;tt&gt;MACRelayUnitBase&lt;/tt&gt;.&#10;//&#10;// Known implementations are MACRelayUnitNP and MACRelayUnitPP.&#10;//&#10;"/>
  <tag type="simple-module" name="MACRelayUnitNP" htmlfile="MACRelayUnitNP-id243601.html" nedfile="NetworkInterfaces/EtherSwitch/MACRelayUnitNP.ned" comment="//&#10;// A MACRelayUnit implementation which models one or more CPUs&#10;// with shared memory, working from a single shared queue.&#10;//&#10;// It also models fixed delay for precessing each frame.&#10;// Finite memory is taken into account by dropping frames if&#10;// total number of bits enqueued exceed a given limit.&#10;//&#10;// A simple scheme for sending PAUSE frames is built in (although&#10;// users will probably change it). When the buffer level goes&#10;// above a high watermark, PAUSE frames are sent on all ports.&#10;// The watermark and the pause time is configurable; use zero&#10;// values to disable the PAUSE feature.&#10;//&#10;"/>
  <tag type="simple-module" name="MACRelayUnitPP" htmlfile="MACRelayUnitPP-id243803.html" nedfile="NetworkInterfaces/EtherSwitch/MACRelayUnitPP.ned" comment="//&#10;// A MACRelayUnit implementation which models one CPU assigned to each&#10;// incoming port, working with shared memory but separate queues.&#10;//&#10;// It also models fixed delay for precessing each frame.&#10;// Finite memory is taken into account by dropping frames if&#10;// total number of bits enqueued exceed a given limit.&#10;//&#10;// A simple scheme for sending PAUSE frames is built in (although&#10;// users will probably change it). When the buffer level goes&#10;// above a high watermark, PAUSE frames are sent on all ports.&#10;// The watermark and the pause time is configurable; use zero&#10;// values to disable the PAUSE feature.&#10;//&#10;"/>
  <tag type="simple-module" name="MPLS" htmlfile="MPLS-id233905.html" nedfile="Network/MPLS/MPLS.ned" comment="//&#10;// Implements the \MPLS protocol.&#10;//&#10;// MPLS module is added between layer 2 and 3 in the OSI model for fast packet&#10;// switching. MPLS should be transparent to signalling protocols. Signalling&#10;// protocol currently implemented in this simulation is \RSVP-TE.&#10;//&#10;// Operations&#10;//&#10;// MPLS packets are represented by the message class MPLSPacket.&#10;// The local LIB (Label Information Base) is stored in a LIBTable module&#10;// in the LSR.&#10;//&#10;// For most of the time, the MPLS module will do the label swapping and&#10;// message forwarding. Upon receiving a labelled packet from another LSR, the&#10;// MPLS first extract the incoming interface and incoming label pair, and then&#10;// look up the local LIB table. If an outgoing label and an outgoing interface&#10;// can be found, the module will perform appropriate label operations (PUSH,&#10;// POP, SWAP) based on the &quot;outLabel&quot; vector containing label and operation&#10;// pairs.&#10;//&#10;// Collaborations&#10;//&#10;// MPLS module is required to interact with L2 (Link Layer) and L3 (Network&#10;// Layer) in the OSI model. In addition, it needs to obtain label information&#10;// from the LIB component and label query result from the LDP module. Messages&#10;// the model communicates with L2 and Network Layers are L2 packets (PPP,&#10;// Frame Relay, ATM, Ethernet, etc.), and \IP native packets. Specifically,&#10;// MPLS module encapsulates \IP packet and is encapsulated in L2 packet.&#10;// Different L2 protocols may require different methods of encapsulation to&#10;// inherit the L2's QoS. This implementation follows a generic approach; it&#10;// assumes no information of QoS from the link layer.&#10;//&#10;"/>
  <tag type="simple-module" name="Mac80211" htmlfile="Mac80211-id251242.html" nedfile="NetworkInterfaces/MF80211/macLayer/Mac80211.ned" comment="//&#10;// Implementation of the 802.11b MAC protocol. This module is intended&#10;// to be used in combination with the SnrEval80211 and Decider80211&#10;// modules as physical layer.&#10;//&#10;// This module supports ad-hoc mode only (does not generate or handle&#10;// management frames), and does not support fragmentation, RTS threshold,&#10;// duplication detection and recovery.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="MassMobility" htmlfile="MassMobility-id226628.html" nedfile="Mobility/MassMobility.ned" comment="//&#10;// This is a random mobility model for a mobile host with a mass. It is the&#10;// one used in &quot;Optimized Smooth Handoffs in Mobile IP&quot; by Perkins &amp; Wang.&#10;//&#10;// &quot;An MH moves within the room according to the following pattern. It moves&#10;// along a straight line for a certain period of time before it makes a turn.&#10;// This moving period is a random number, normally distributed with average of&#10;// 5 seconds and standard deviation of 0.1 second. When it makes a turn, the&#10;// new direction (angle) in which it will move is a normally distributed&#10;// random number with average equal to the previous direction and standard&#10;// deviation of 30 degrees. Its speed is also a normally distributed random&#10;// number, with a controlled average, ranging from 0.1 to 0.45 (unit/sec), and&#10;// standard deviation of 0.01 (unit/sec). A new such random number is picked&#10;// as its speed when it makes a turn. This pattern of mobility is intended to&#10;// model node movement during which the nodes have momentum, and thus do not&#10;// start, stop, or turn abruptly. When it hits a wall, it reflects off the&#10;// wall at the same angle; in our simulated world, there is little other&#10;// choice.&quot;&#10;//&#10;// This implementation can be parameterized a bit more, via the changeInterval,&#10;// changeAngleBy and changeSpeedBy parameters. The parameters described above&#10;// correspond to the following settings:&#10;//    - changeInterval = normal(5, 0.1)&#10;//    - changeAngleBy = normal(0, 30)&#10;//    - speed = normal(avgSpeed, 0.01)&#10;//&#10;// @see ChannelControl&#10;// @author Emin Ilker Cetinbas, Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="NAMTrace" htmlfile="NAMTrace-id272601.html" nedfile="World/NAMTrace.ned" comment="//&#10;// NAMTrace manages a &quot;nam&quot; trace file which can be played back with ns2's&#10;// Network ANimator, nam. The trace is actually written by NAMTraceWriter&#10;// modules which should occur per host or router.&#10;//&#10;// @see NAMTraceWriter&#10;//&#10;"/>
  <tag type="simple-module" name="NAMTraceWriter" htmlfile="NAMTraceWriter-id272225.html" nedfile="Util/NAMTraceWriter.ned" comment="//&#10;// When placed inside a host or router, it writes a NAM trace, based on &#10;// notifications it receives via the NotificationBoard. Expects to find &#10;// a NAMTrace module named &quot;nam&quot; at network level.&#10;//&#10;// This module has no gates and does not process messages.&#10;//&#10;// @see NAMTrace, NotificationBoard&#10;//&#10;"/>
  <tag type="simple-module" name="NetworkConfigurator" htmlfile="NetworkConfigurator-id227931.html" nedfile="Network/AutoRouting/NetworkConfigurator.ned" comment="//&#10;// Configures \IP addresses and routing tables for a network.&#10;//&#10;// This module does't connect to any other modules (it has no gates),&#10;// and should have only one instance in the whole model. The module&#10;// will only run once, at the beginning of the simulation.&#10;// When it runs, it will:&#10;//&#10;//   -#  assign \IP addresses to hosts and routers.&#10;//   -#  then it'll discover the topology of the network (using OMNeT++'s&#10;//       cTopology class), and calculate shortest paths;&#10;//   -#  finally, it will add routes which correspond to the shortest&#10;//       paths to the routing tables (see RoutingTable::addRoutingEntry()).&#10;//&#10;// How does it know which modules are routers, hosts, et.c that need to&#10;// be configured, and what is the network topology? The configurator&#10;// picks all modules of types listed in the moduleTypes parameter and&#10;// their connections, and builds a graph from it. Then it runs Dijstra's&#10;// shortest path algorithm on it.&#10;//&#10;// To avoid interference with the above algorithm, it's recommended that&#10;// no host or router should have its address set explicitly, and&#10;// no routes are set up manually. Practically, routing files (.irt, .mrt)&#10;// should be missing or empty.&#10;//&#10;// All the above takes place in initialization stage 2. (In stage 0,&#10;// interfaces register themselves in the InterfaceTable modules, and&#10;// in stage 1, routing files are read.)&#10;//&#10;"/>
  <tag type="simple-module" name="NotificationBoard" htmlfile="NotificationBoard-id225662.html" nedfile="Base/NotificationBoard.ned" comment="//&#10;// Using NotificationBoard, modules can now notify each other about&#10;// &quot;events&quot; such as routing table changes, interface status changes (up/down),&#10;// interface configuration changes, wireless handovers, changes in the state&#10;// of the wireless channel, mobile node position changes, etc.&#10;//&#10;// The NotificationBoard has exactly one instance within a host or router&#10;// model, and acts as a intermediary between module where state changes&#10;// can occur and modules which are interested in learning about those&#10;// changes.&#10;//&#10;// NotificationBoard is accessed via direct C++ method calls (not&#10;// message exchange). Modules can &quot;subscribe&quot; to categories of changes&#10;// (e.g. &quot;routing table changed&quot; or &quot;radio channel became empty&quot;).&#10;// When such a change occurs, the corresponding module (e.g. the RoutingTable&#10;// or the physical layer module) will let NotificationBoard know, and&#10;// it will disseminate this information to all interested modules.&#10;//&#10;"/>
  <tag type="simple-module" name="NullMobility" htmlfile="NullMobility-id226704.html" nedfile="Mobility/NullMobility.ned" comment="//&#10;// This mobility module does nothing; it can be used for stationary nodes.&#10;//&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="OSPFRouting" htmlfile="OSPFRouting-id234017.html" nedfile="Network/OSPFv2/OSPFRouting.ned" comment="//&#10;// Implements \OSPFRouting.&#10;//&#10;"/>
  <tag type="simple-module" name="OutputQueue" htmlfile="OutputQueue-id236035.html" nedfile="Network/Queue/OutputQueue.ned" comment="//&#10;// Prototype for per-NIC output queues. Concrete queues can implement&#10;// drop-tail, RED etc. policy.&#10;//&#10;// Interface to Layer 2 modules: The C++ class implementing the queue&#10;// must implement (i.e. subclass from) IPassiveQueue, and should&#10;// send a packet whenever the L2 module asks for one by calling the&#10;// requestPacket() method.&#10;//&#10;// @see DropTailQueue, DropTailQoSQueue, REDQueue&#10;//&#10;"/>
  <tag type="simple-module" name="PPP" htmlfile="PPP-id253311.html" nedfile="NetworkInterfaces/PPP/PPP.ned" comment="//&#10;// \PPP implementation.&#10;//&#10;// Packets are encapsulated in PPPFrame.&#10;//&#10;// \PPP is a complex protocol with strong support for link configuration&#10;// and maintenance. This model ignores those details, and only performs&#10;// simple encapsulation/decapsulation and queuing.&#10;//&#10;// In routers, \PPP relies on an external queue module (see OutputQueue)&#10;// to model finite buffer, implement QoS and/or RED, and requests packets&#10;// from this external queue one-by-one.&#10;//&#10;// In hosts, no such queue is used, so \PPP contains an internal&#10;// queue named txQueue to queue up packets waiting for transmission.&#10;// Conceptually, txQueue is of infinite size, but for better diagnostics&#10;// one can specify a hard limit in the txQueueLimit parameter -- if this is&#10;// exceeded, the simulation stops with an error.&#10;//&#10;// There is no buffering done on received packets -- they are just decapsulated&#10;// and sent up immediately.&#10;//&#10;// @see PPPInterface, OutputQueue, PPPFrame&#10;//&#10;"/>
  <tag type="simple-module" name="PingApp" htmlfile="PingApp-id221440.html" nedfile="Applications/PingApp/PingApp.ned" comment="//&#10;// Generates ping requests and calculates the packet loss and round trip&#10;// parameters of the replies. &#10;//&#10;// Start/stop time, interval etc can be specified via parameters. To disable,&#10;// specify empty destAddr or stopTime&lt;=startTime.&#10;//&#10;// Every ping request is sent out with a sequence number, and replies are&#10;// expected to arrive in the same order. Whenever there's a jump in the&#10;// in the received ping responses' sequence number (e.g. 1, 2, 3, 5), then&#10;// the missing pings (number 4 in this example) is counted as lost.&#10;// Then if it still arrives later (that is, a reply with a sequence number&#10;// smaller than the largers one received so far) it will be counted as&#10;// out-of-sequence arrival. So the number of really lost pings will be&#10;// &quot;lost&quot; minus &quot;out-of-order&quot; (assuming there's no duplicate or bogus reply).&#10;//&#10;// Uses PingPayload as payload for the ICMP(v6) Echo Request/Reply packets.&#10;//&#10;// @see PingPayload, ICMP, ICMPv6Core&#10;//&#10;"/>
  <tag type="simple-module" name="REDQueue" htmlfile="REDQueue-id236337.html" nedfile="Network/Queue/REDQueue.ned" comment="//&#10;// RED (Random Early Detection) queue, to be used in routers' network&#10;// interfaces. Conforms to the OutputQueue interface.&#10;//&#10;// Implements the original RED algorithm from&#10;// &quot;Random Early Detection Gateways for Congestion Avoidance&quot; by&#10;// Sally Floyd and Van Jacobson, 1993.&#10;//&#10;// The code is based on the algorithm described on p10 of the paper:&#10;//&#10;// &lt;pre&gt;&#10;// Initialization:&#10;//    avg &lt;- 0&#10;//    count &lt;- -1&#10;// for each packet arrival&#10;//    calculate the new average queue size avg:&#10;//        if the queue is nonempty&#10;//            avg &lt;- (1-wq)*avg + wq*q&#10;//        else&#10;//            m &lt;- f(time-q_time)&#10;//            avg &lt;- (1-wq)^m * avg&#10;//    if minth &lt;= avg &lt; maxth&#10;//        increment count&#10;//        calculate probability pa:&#10;//            pb &lt;- maxp*(avg-minth) / (maxth-minth)&#10;//            pa &lt;- pb / (1-count*pb)&#10;//        with probability pa:&#10;//            mark the arriving packet&#10;//            count &lt;- 0&#10;//    else if maxth &lt;= avg&#10;//        mark the arriving packet&#10;//        count &lt;- 0&#10;//    else count &lt;- -1&#10;// when queue becomes empty&#10;//    q_time &lt;- time&#10;//&#10;// Saved Variables:&#10;//    - avg: average queue size&#10;//    - q_time: start of the queue idle time&#10;//    - count: packets since last marked packet&#10;//&#10;// Fixed parameters:&#10;//    - wq: queue weight&#10;//    - minth: minimum threshold for queue&#10;//    - maxth: maximum threshold for queue&#10;//    - maxp: maximum value for pb&#10;//&#10;// Other:&#10;//    - pa: current packet-marking probability&#10;//    - q: current queue size&#10;//    - time: current time&#10;//    - f(t): a linear function of the time t&#10;// &lt;/pre&gt;&#10;//&#10;// The function f() is supposed to estimate the number of packets&#10;// that could have arrived during the idle interval.&#10;// We use &lt;i&gt;f(t) = pkrate * t&lt;/i&gt;, where &lt;i&gt;pkrate = 1/s&lt;/i&gt;,&#10;// s being the typical transmission time for a small packet&#10;// as mentioned in Section 11 of the paper.&#10;//&#10;// Example parameter values: wq = 0.002, minth = 5 packets, maxth = 15 packets,&#10;// maxp = 1/50 = 0.02 and pkrate = 12000 (~1K packets on 100Mbps link).&#10;//&#10;"/>
  <tag type="simple-module" name="RSVP" htmlfile="RSVP-id236175.html" nedfile="Network/RSVP_TE/RSVP.ned" comment="//&#10;// Implements \RSVP-TE, a signalling protocol for MPLS. The module&#10;// processes \RSVP-TE messages, installs labels and does the reservation&#10;// along LSP paths.&#10;//&#10;// Paths can be specified statically in an XML config file (&quot;traffic&quot;&#10;// parameter), or can be set up and torn down dynamically with ScenarioManager&#10;// commands.&#10;//&#10;// An example traffic.xml file:&#10;//&#10;//# FIXME verify against the code, and document formally (DTD)!&#10;//# &lt;setup_pri&gt;, &lt;holding_pri&gt;, &lt;sender&gt;, &lt;owner&gt;, &lt;max_delay&gt; elements&#10;//# are implemented but missing from this doc!&#10;//&#10;// &lt;pre&gt;&#10;// &lt;?xml version=&quot;1.0&quot;?&gt;&#10;// &lt;sessions&gt;&#10;//     &lt;session&gt;&#10;//         &lt;endpoint&gt;host3&lt;/endpoint&gt;&#10;//         &lt;tunnel_id&gt;1&lt;/tunnel_id&gt;&#10;//         &lt;paths&gt;&#10;//             &lt;path&gt;&#10;//                 &lt;lspid&gt;100&lt;/lspid&gt;&#10;//                 &lt;bandwidth&gt;100000&lt;/bandwidth&gt;&#10;//                 &lt;route&gt;&#10;//                     &lt;node&gt;10.1.1.1&lt;/node&gt;&#10;//                     &lt;lnode&gt;10.1.2.1&lt;/lnode&gt;&#10;//                     &lt;node&gt;10.1.4.1&lt;/node&gt;&#10;//                     &lt;node&gt;10.1.5.1&lt;/node&gt;&#10;//                 &lt;/route&gt;&#10;//                 &lt;permanent&gt;true&lt;/permanent&gt;&#10;//                 &lt;color&gt;100&lt;/color&gt;&#10;//             &lt;/path&gt;&#10;//         &lt;/paths&gt;&#10;//     &lt;/session&gt;&#10;// &lt;/sessions&gt;&#10;// &lt;/pre&gt;&#10;//&#10;// In the route, &lt;node&gt; stands for strict hop, and &lt;lnode&gt; for loose hop.&#10;//&#10;// RSVP understands the &quot;add-session&quot; and &quot;del-session&quot; ScenarioManager&#10;// commands. The contents of the &lt;add-session&gt; element can be the same&#10;// as the &lt;session&gt; element for the traffic.xml above.&#10;// The &lt;del-command&gt; element syntax is also similar, but only&#10;// &lt;endpoint&gt;, &lt;tunnel_id&gt; and &lt;lspid&gt; needs to be specified.&#10;//&#10;// The following is an example scenario.xml file:&#10;//&#10;// &lt;pre&gt;&#10;// &lt;?xml version=&quot;1.0&quot;?&gt;&#10;// &lt;scenario&gt;&#10;//     &lt;at t=&quot;2&quot;&gt;&#10;//         &lt;add-session module=&quot;LSR1.rsvp&quot;&gt;&#10;//             &lt;endpoint&gt;10.2.1.1&lt;/endpoint&gt;&#10;//             &lt;tunnel_id&gt;1&lt;/tunnel_id&gt;&#10;//             &lt;paths&gt;&#10;//                 ...&#10;//             &lt;/paths&gt;&#10;//         &lt;/add-session&gt;&#10;//     &lt;/at&gt;&#10;//     &lt;at t=&quot;2.4&quot;&gt;&#10;//         &lt;del-session module=&quot;LSR1.rsvp&quot;&gt;&#10;//             &lt;endpoint&gt;10.2.1.1&lt;/endpoint&gt;&#10;//             &lt;tunnel_id&gt;1&lt;/tunnel_id&gt;&#10;//             &lt;paths&gt;&#10;//                 &lt;path&gt;&#10;//                     &lt;lspid&gt;100&lt;/lspid&gt;&#10;//                 &lt;/path&gt;&#10;//             &lt;/paths&gt;&#10;//         &lt;/del-session&gt;&#10;//     &lt;/at&gt;&#10;// &lt;/scenario&gt;&#10;// &lt;/pre&gt;&#10;//&#10;// \RSVP messages are subclassed from RSVPMessage, and include RSVPPathMsg,&#10;// RSVPPathTear, RSVPPathError, RSVPResvMsg and RSVPHelloMsg.&#10;//&#10;// \RSVP-TE communicates with the following components in the system:&#10;// TED, MPLS, and may receive commands from ScenarioManager.&#10;//&#10;"/>
  <tag type="simple-module" name="RTCPModule" htmlfile="RTCPModule-id269546.html" nedfile="Transport/RTP/RTCPModule.ned" comment=""/>
  <tag type="simple-module" name="RTPApplication" htmlfile="RTPApplication-id269612.html" nedfile="Transport/RTP/RTPApplication.ned" comment=""/>
  <tag type="simple-module" name="RTPModule" htmlfile="RTPModule-id270718.html" nedfile="Transport/RTP/RTPModule.ned" comment=""/>
  <tag type="simple-module" name="RTPPayloadReceiver" htmlfile="RTPPayloadReceiver-id270819.html" nedfile="Transport/RTP/RTPPayloadReceiver.ned" comment=""/>
  <tag type="simple-module" name="RTPPayloadSender" htmlfile="RTPPayloadSender-id270876.html" nedfile="Transport/RTP/RTPPayloadSender.ned" comment=""/>
  <tag type="simple-module" name="RTPProfile" htmlfile="RTPProfile-id270922.html" nedfile="Transport/RTP/RTPProfile.ned" comment=""/>
  <tag type="simple-module" name="Radio" htmlfile="Radio-id254697.html" nedfile="NetworkInterfaces/Radio/Radio.ned" comment="//&#10;// Prototype for radio modules. Radio modules deal with the transmission&#10;// of frames over a wireless medium (the radio channel).&#10;//&#10;// &lt;b&gt;Transmission&lt;/b&gt;&#10;//&#10;// Upper layers (wireless L2 protocols) can send frames to the radio&#10;// module. Frames will be encapsulated into AirFrame messages and&#10;// distributed to other network nodes within interference distance.&#10;// The AirFrame represents the signal in the radio channel, and&#10;// its fields hold properties of the transmission like the transmit power.&#10;//&#10;// The global ChannelControl module keeps track of node positions,&#10;// and knows which nodes are within interference distance of others&#10;// (neighbour list). When transmitting, the radio module obtains the&#10;// neighbour list, and sends a copy of the AirFrame to each neighbour.&#10;//&#10;//&#10;// &lt;b&gt;Reception&lt;/b&gt;&#10;//&#10;// Received AirFrame messages get delivered to the radioIn gate of the&#10;// module. If it was found to have been received correctly, it gets&#10;// decapsulated and the frame sent to the upper layer.&#10;//&#10;// Note: currently the packet is also sent up if it was NOT received&#10;// incorrectly, with its message kind set to COLLISION or BITERROR.&#10;// This may change in the future, as erroneous receptions could also&#10;// be signalled via the NotificationBoard.&#10;//&#10;// Determining whether the frame was received correctly is a complicated&#10;// process. The AbstractRadio C++ class from which the Ieee80211Radio&#10;// and GenericRadio are derived, basically first calculates the received&#10;// power of the frame, taking a path loss model into account.&#10;// Then it calculates the signal-noise ratio, thermal noise and other&#10;// frames being counted as noise. It is determined from the SNR&#10;// whether the packet was received correctly, taking modulation&#10;// scheme and possible forward error correction into account.&#10;// For details please see the C++ code and its documentation.&#10;//&#10;//&#10;// &lt;b&gt;Monitoring the radio state&lt;/b&gt;&#10;//&#10;// Wireless L2 protocols and other modules within the node can monitor&#10;// radio transmissions and receptions by subscribing to the&#10;// &lt;code&gt;NF_RADIOSTATE_CHANGED&lt;/code&gt; category at the NotificationBoard&#10;// module of the node.&#10;//&#10;//&#10;// &lt;b&gt;Dynamically configuring the radio&lt;/b&gt;&#10;//&#10;// The bitrate and the receive/transmit channel can be changed by sending&#10;// Radio a blank cMessage with &lt;tt&gt;PHY_C_CONFIGURERADIO&lt;/tt&gt; as message kind, and&#10;// a PhyControlInfo object attached to it as control info, to hold the&#10;// new bitrate and/or channel number. If the radio is currently transmitting,&#10;// the change will actually take place after the transmission is completed.&#10;//&#10;// It is also possible to specify a different bitrate for individual frames;&#10;// to do that, attach a PhyControlInfo with bitrate filled in to the frame.&#10;//&#10;"/>
  <tag type="simple-module" name="RandomWPMobility" htmlfile="RandomWPMobility-id226892.html" nedfile="Mobility/RandomWPMobility.ned" comment="//&#10;// Random Waypoint mobility model.&#10;//&#10;// The node moves in line segments. For each line segment, a random destination&#10;// position (distributed uniformly over the playground) and a random speed&#10;// is chosen. You can define a speed as a variate from which a new value&#10;// will be drawn for each line segment; it is customary to specify it as&#10;// uniform(minSpeed, maxSpeed). When the node reaches the target position,&#10;// it waits for the time waitTime which can also be defined as a variate.&#10;// After this time the the algorithm calculates a new random position, etc.&#10;//&#10;// This model was written by Georg Lutz (GeorgLutz AT gmx DOT de) for his&#10;// diploma thesis &quot;Effizientes Modell fuer Funkverbindungen in 4G-Netzen fuer&#10;// OMNeT++&quot; (Efficient model for radio links in 4G networks for OMNeT++)&#10;// at Institut fuer Telematik, Universitaet Karlsruhe (Institute for&#10;// Telematics, University Karlsruhe, Germany), 2005-06-21. Slightly modified&#10;// by Andras Varga 2005.06.22.&#10;//&#10;// @author Georg Lutz&#10;//&#10;"/>
  <tag type="simple-module" name="RectangleMobility" htmlfile="RectangleMobility-id226799.html" nedfile="Mobility/RectangleMobility.ned" comment="//&#10;// Moves the node around a rectangle.&#10;//&#10;// @see ChannelControl&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="RoutingTable" htmlfile="RoutingTable-id231049.html" nedfile="Network/IPv4/RoutingTable.ned" comment="//&#10;// Stores the routing table. (Per-interface configuration is stored in &#10;// InterfaceTable.)&#10;//&#10;// For hosts, the routerId module parameter should be empty (&quot;&quot;),&#10;// in which case the loopback IP address will be set to 127.0.0.1/8.&#10;// For routers which have a routerId set, the loopback address will be set to&#10;// routerId. (See also RFC 2072 &quot;\Router Renumbering Guide&quot;.)&#10;//&#10;// RouterId may also be set to the string &lt;tt&gt;&quot;auto&quot;&lt;/tt&gt;, in which case the&#10;// highest interface address will be chosen as routerId; the loopback address&#10;// will remain 127.0.0.1/8.&#10;//&#10;// The routing table is read from a file (parameter routingFile);&#10;// the file can also fill in or overwrite interface settings.&#10;// The file format is documented &lt;a href=&quot;irt.html&quot;&gt;here&lt;/a&gt;.&#10;//&#10;// Note that many protocols don't require routerId to be routable, but some&#10;// others do -- so it is probably a good idea to set up routable routerIds.&#10;//&#10;// This module has no gates; all functionality can be accessed via member&#10;// functions of the C++ module class. For detailed info, please see the C++&#10;// documentation of the class (Doxygen).&#10;//&#10;// @see InterfaceTable&#10;// @author: Jochen Reber, Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="RoutingTable6" htmlfile="RoutingTable6-id232346.html" nedfile="Network/IPv6/RoutingTable6.ned" comment="//&#10;// \IPv6 Routing Table and Neighbour Discovery data structures.&#10;//&#10;// @see IPv6, IPv6NeighbourDiscovery, ICMPv6&#10;//&#10;"/>
  <tag type="simple-module" name="ScenarioManager" htmlfile="ScenarioManager-id272727.html" nedfile="World/ScenarioManager.ned" comment="//&#10;// ScenarioManager is for setting up and controlling simulation experiments.&#10;// You can schedule certain events to take place at specified times,&#10;// like changing a parameter value, changing the bit error rate of&#10;// a connection, removing or adding connections, removing or&#10;// adding routes in a routing table, etc, so that you can observe the&#10;// transient behaviour.&#10;//&#10;// ScenarioManager executes a script specified in XML. It has a few&#10;// built-in commands, while other commands are dispatched to be carried out&#10;// by given simple modules. (The C++ class of these simple modules' needs&#10;// to implement the IScriptable interface, and the processCommand() method&#10;// must be redefined accordingly).&#10;//&#10;// An example script:&#10;//&#10;// &lt;pre&gt;&#10;// &lt;scenario&gt;&#10;//     &lt;set-param t=&quot;10&quot; module=&quot;host[1].mobility&quot; par=&quot;speed&quot; value=&quot;5&quot;/&gt;&#10;//     &lt;set-param t=&quot;20&quot; module=&quot;host[1].mobility&quot; par=&quot;speed&quot; value=&quot;30&quot;/&gt;&#10;//     &lt;at t=&quot;50&quot;&gt;&#10;//         &lt;set-param module=&quot;host[2].mobility&quot; par=&quot;speed&quot; value=&quot;10&quot;/&gt;&#10;//         &lt;set-param module=&quot;host[3].mobility&quot; par=&quot;speed&quot; value=&quot;10&quot;/&gt;&#10;//     &lt;/at&gt;&#10;// &lt;/scenario&gt;&#10;// &lt;/pre&gt;&#10;//&#10;// Built-in commands: &lt;set-param&gt;, &lt;set-channel-attr&gt;, &lt;at&gt;.&#10;//&#10;// All commands have a t attribute which carries the simulation time&#10;// at which the command has to be carried out. You can group several commands&#10;// to be carried out at the same simulation time using &lt;at&gt;, and&#10;// then only the &lt;at&gt; command is needed to have a t attribute.&#10;//&#10;// Supported attributes:&#10;//    - &lt;set-param&gt;: module, par, value.&#10;//    - &lt;set-channel-attr&gt;: src-module, src-gate, attr, value.&#10;//&#10;"/>
  <tag type="simple-module" name="SimpleClassifier" htmlfile="SimpleClassifier-id236441.html" nedfile="Network/RSVP_TE/SimpleClassifier.ned" comment="//&#10;// TODO documentation&#10;//&#10;"/>
  <tag type="simple-module" name="Sink" htmlfile="Sink-id225636.html" nedfile="Base/Sink.ned" comment="//&#10;// Silently discards all input messages.&#10;//&#10;"/>
  <tag type="simple-module" name="SnrDecider" htmlfile="SnrDecider-id251834.html" nedfile="NetworkInterfaces/MF80211/phyLayer/decider/SnrDecider.ned" comment="//&#10;// Decider module to be used with SnrEval&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="SnrEval" htmlfile="SnrEval-id252171.html" nedfile="NetworkInterfaces/MF80211/phyLayer/snrEval/SnrEval.ned" comment="//&#10;// Represents the radio. Frames received from higher layers (typically the&#10;// MAC protocol) are transmitted on the radio channel, using the global&#10;// ChannelControl module. Frames received on the radio channel will have&#10;// their signal-noise ratio evaluated and passed up to the decider.&#10;// (It is the decider's task to determine whether the frame was received&#10;// correctly, and pass it up to the MAC layer).&#10;//&#10;// The receive/transmit channel (frequency) can be changed by sending&#10;// SnrEval a blank cMessage with PHY_C_CONFIGURERADIO as message kind, and&#10;// a PhyControlInfo object attached to it as control info, to hold the&#10;// new channel number. If the radio is currently transmitting, the channel&#10;// switch will actually take place after the transmission is completed.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;//# FIXME merge docu with BasicSnrEval's&#10;"/>
  <tag type="simple-module" name="SnrEval80211" htmlfile="SnrEval80211-id252310.html" nedfile="NetworkInterfaces/MF80211/phyLayer/snrEval/SnrEval80211.ned" comment="//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;"/>
  <tag type="simple-module" name="TCP" htmlfile="TCP-id271256.html" nedfile="Transport/TCP/TCP.ned" comment="//&#10;// \TCP protocol implementation. Supports RFC 793, RFC 1122, RFC 2001.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;// A \TCP segment is represented by the class TCPSegment.&#10;//&#10;// &lt;b&gt;Communication with clients&lt;/b&gt;&#10;//&#10;// For communication between client applications and TCP, the TcpCommandCode&#10;// and TcpStatusInd enums are used as message kinds, and TCPCommand&#10;// and its subclasses are used as control info.&#10;//&#10;// To open a connection from a client app, send a cMessage to TCP with&#10;// TCP_C_OPEN_ACTIVE as message kind and a TCPOpenCommand object filled in&#10;// and attached to it as control info. (The peer TCP will have to be LISTENing;&#10;// the server app can achieve this with a similar cMessage but TCP_C_OPEN_PASSIVE&#10;// message kind.) With passive open, there's a possibility to cause the connection&#10;// &quot;fork&quot; on an incoming connection, leaving the original connection LISTENing&#10;// on the port (see the fork field in TCPOpenCommand).&#10;//&#10;// The client app can send data by assigning the TCP_C_SEND message kind&#10;// and attaching a TCPSendCommand control info object to the data packet,&#10;// and sending it to TCP. The server app will receive data as messages&#10;// with the TCP_I_DATA message kind and TCPSendCommand control info.&#10;// (Whether you'll receive the same or identical messages, or even whether&#10;// you'll receive data in the same sized chunks as sent depends on the&#10;// sendQueueClass and receiveQueueClass used, see below. With&#10;// TCPVirtualDataSendQueue and TCPVirtualDataRcvQueue set, message objects&#10;// and even message boundaries are not preserved.)&#10;//&#10;// To close, the client sends a cMessage to TCP with the TCP_C_CLOSE message kind&#10;// and TCPCommand control info.&#10;//&#10;// TCP sends notifications to the application whenever there's a significant&#10;// change in the state of the connection: established, remote TCP closed,&#10;// closed, timed out, connection refused, connection reset, etc. These&#10;// notifications are also cMessages with message kind TCP_I_xxx&#10;// (TCP_I_ESTABLISHED, etc.) and TCPCommand as control info.&#10;//&#10;// One TCP module can serve several application modules, and several&#10;// connections per application. The &lt;i&gt;k&lt;/i&gt;th application connects to TCP's&#10;// from_appl[k] and to_appl[k] ports. When talking to applications, a&#10;// connection is identified by the (application port index, connId) pair,&#10;// where connId is assigned by the application in the OPEN call.&#10;//&#10;// &lt;b&gt;Sockets&lt;/b&gt;&#10;//&#10;// The TCPSocket C++ class is provided to simplify managing \TCP connections&#10;// from applications. TCPSocket handles the job of assembling and sending&#10;// command messages (OPEN, CLOSE, etc) to TCP, and it also simplifies&#10;// the task of dealing with packets and notification messages coming from TCP.&#10;//&#10;// &lt;b&gt;Communication with the \IP layer&lt;/b&gt;&#10;//&#10;// The TCP model relies on sending and receiving IPControlInfo objects&#10;// attached to \TCP segment objects as control info&#10;// (see cMessage::setControlInfo()).&#10;//&#10;// &lt;b&gt;Configuring TCP&lt;/b&gt;&#10;//&#10;// The module parameters sendQueueClass and receiveQueueClass should be&#10;// set the names of classes that manage the actual send and receive queues.&#10;// Currently you have two choices:&#10;//&#10;//   -# set them to &quot;TCPVirtualDataSendQueue&quot; and &quot;TCPVirtualDataRcvQueue&quot;.&#10;//      These classes manage &quot;virtual bytes&quot;, that is, only byte counts are&#10;//      transmitted over the \TCP connection and no actual data. cMessage&#10;//      contents, and even message boundaries are not preserved with these&#10;//      classes: for example, if the client sends a single cMessage with&#10;//      length = 1 megabyte over TCP, the receiver-side client will see a&#10;//      sequence of MSS-sized messages.&#10;//&#10;//   -# use &quot;TCPMsgBasedSendQueue&quot; and &quot;TCPMsgBasedRcvQueue&quot;, which transmit&#10;//      cMessage objects (and subclasses) over a \TCP connection. The same&#10;//      message object sequence that was sent by the client to the&#10;//      sender-side TCP entity will be reproduced on the receiver side.&#10;//      If a client sends a cMessage with length = 1 megabyte, the&#10;//      receiver-side client will receive the same message object (or a clone)&#10;//      after the TCP entities have completed simulating the transmission&#10;//      of 1 megabyte over the connection. This is a different behaviour&#10;//      from TCPVirtualDataSendQueue/RcvQueue.&#10;//&#10;// It depends on the client (app) modules which sendQueue/rcvQueue they require.&#10;// For example, TCPGenericSrvApp needs message-based sendQueue/rcvQueue,&#10;// while TCPEchoApp or TCPSinkApp can work with any (but TCPEchoApp will&#10;// display different behaviour with both!)&#10;//&#10;// In the future, other send queue and receive queue classes may be&#10;// implemented, e.g. to allow transmission of &quot;raw bytes&quot; (actual byte arrays).&#10;//&#10;// The \TCP flavour supported depends on the value of the tcpAlgorithmClass&#10;// module parameters, e.g. &quot;TCPTahoe&quot; or &quot;TCPReno&quot;. In the future, other&#10;// classes can be written which implement New Reno, Vegas, LinuxTCP (which&#10;// differs from others) or other variants.&#10;//&#10;// Note that TCPOpenCommand allows sendQueueClass, receiveQueueClass and&#10;// tcpAlgorithmClass to be chosen per-connection.&#10;//&#10;// Notes:&#10;//  - if you do active OPEN, then send data and close before the connection&#10;//    has reached ESTABLISHED, the connection will go from SYN_SENT to CLOSED&#10;//    without actually sending the buffered data. This is consistent with &#10;//    rfc 763 but may not be what you'd expect.&#10;//  - handling segments with SYN+FIN bits set (esp. with data too) is&#10;//    inconsistent across TCPs, so check this one if it's of importance&#10;//&#10;// &lt;b&gt;Standards&lt;/b&gt;&#10;//&#10;// The TCP module itself implements the following:&#10;//  - all RFC793 \TCP states and state transitions&#10;//  - connection setup and teardown as in RFC793&#10;//  - generally, RFC793 compliant segment processing&#10;//  - all socked commands (except RECEIVE) and indications&#10;//  - receive buffer to cache above-sequence data and data not yet forwarded&#10;//    to the user&#10;//  - CONN-ESTAB timer, SYN-REXMIT timer, 2MSL timer, FIN-WAIT-2 timer&#10;//&#10;// The TCPTahoe and TCPReno algorithms implement:&#10;//  - delayed acks, with 200ms timeout (optional)&#10;//  - Nagle's algorithm (optional)&#10;//  - Jacobson's and Karn's algorithms for round-trip time measurement and&#10;//    adaptive retransmission&#10;//  - \TCP Tahoe (Fast Retransmit), \TCP Reno (Fast Retransmit and Fast Recovery)&#10;//&#10;// Missing bits:&#10;//  - URG and PSH bits not handled. Receiver always acts as if PSH was set&#10;//    on all segments: always forwards data to the app as soon as possible.&#10;//  - finite receive buffer size is not modelled (always the maximum&#10;//    window size, currently 16K is advertised)&#10;//  - no RECEIVE command. Received data are always forwarded to the app as&#10;//    soon as possible, as if the app issued a very large RECEIVE request&#10;//    at the beginning. This means there's currently no flow control&#10;//    between TCP and the app.&#10;//  - no \TCP header options (e.g. MSS is currently module parameter; no SACK;&#10;//    no timestamp option for more frequent round-trip time measurement per &#10;//    rfc 2988 section 3&#10;//  - all timeouts are precisely calculated: timer granularity (which is caused &#10;//    by &quot;slow&quot; and &quot;fast&quot; i.e. 500ms and 200ms timers found in many *nix \TCP&#10;//    implementations) is not simulated&#10;//&#10;// TCPTahoe/TCPReno issues and missing features:&#10;//  - PERSIST timer not implemented (currently no problem, because receiver&#10;//    never advertises 0 window size)&#10;//  - KEEPALIVE not implemented (idle connections never time out)&#10;//  - Nagle's algorithm possibly not precisely implemented&#10;//&#10;// The above problems are relatively easy to fix, and will be resolved in the&#10;// next iteration. Also, other TCPAlgorithms will be added.&#10;//&#10;// &lt;b&gt;Tests&lt;/b&gt;&#10;//&#10;// There are automated test cases (*.test files) for TCP -- see the Test&#10;// directory in the source distribution.&#10;//&#10;"/>
  <tag type="simple-module" name="TCPApp" htmlfile="TCPApp-id219687.html" nedfile="Applications/TCPApp/TCPApp.ned" comment="//&#10;// Template for TCP applications.&#10;//&#10;// This is not an actual module type. It only shows which gates an TCP app &#10;// needs, to be able to be used in StandardHost etc.&#10;//&#10;"/>
  <tag type="simple-module" name="TCPBasicClientApp" htmlfile="TCPBasicClientApp-id219784.html" nedfile="Applications/TCPApp/TCPBasicClientApp.ned" comment="//&#10;// Client for a generic request-response style protocol over TCP.&#10;// May be used as a rough model of HTTP or FTP users.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;// The model communicates with the server in sessions. During a session,&#10;// the client opens a single \TCP connection to the server, sends several&#10;// requests (always waiting for the complete reply to arrive before&#10;// sending a new request), and closes the connection.&#10;//&#10;// The server app should be TCPGenericSrvApp; the model sends GenericAppMsg&#10;// messages.&#10;//&#10;// Example settings:&#10;//&#10;// FTP:&#10;// &lt;pre&gt;&#10;//    numRequestsPerSession = exponential(3)&#10;//    requestLength = truncnormal(20,5)&#10;//    replyLength = exponential(1000000)&#10;// &lt;/pre&gt;&#10;//&#10;// Note that this module doesn't open separate \TCP connections for commands&#10;// and data transfer as the FTP protocol.&#10;//&#10;// HTTP:&#10;// &lt;pre&gt;&#10;//    numRequestsPerSession = 1 &lt;i&gt;(HTTP 1.0)&lt;/i&gt;&#10;//    numRequestsPerSession = exponential(5) &lt;i&gt;(HTTP 1.1, with keepalive)&lt;/i&gt;&#10;//    requestLength = truncnormal(350,20)&#10;//    replyLength = exponential(2000)&#10;// &lt;/pre&gt;&#10;//&#10;// Note that since most web pages contain images and may contain frames,&#10;// applets etc, possibly from various servers, and browsers usually download&#10;// these items in parallel to the main HTML document, this module cannot&#10;// serve as a realistic web client.&#10;//&#10;// Also, with HTTP 1.0 it is the server that closes the connection after&#10;// sending the response, while in this model it is the client.&#10;//&#10;// @see TCPGenericSrvApp, GenericAppMsg, TelnetApp&#10;//&#10;"/>
  <tag type="simple-module" name="TCPDump" htmlfile="TCPDump-id272194.html" nedfile="Util/TCPDump.ned" comment="//&#10;// Provides tcpdump-like functionality&#10;//&#10;"/>
  <tag type="simple-module" name="TCPEchoApp" htmlfile="TCPEchoApp-id220009.html" nedfile="Applications/TCPApp/TCPEchoApp.ned" comment="//&#10;// Accepts any number of incoming TCP connections, and sends back the&#10;// messages that arrive on them, The lengths of the messages are&#10;// multiplied by echoFactor before sending them back (echoFactor=1 will&#10;// result in sending back the same message unmodified.) The reply can also be&#10;// delayed by a constant time (echoDelay parameter).&#10;//&#10;// When TCPEchoApp receives data packets from TCP (and such, when they can be&#10;// echoed) depends on the sendQueue/receiveQueue setting of TCP.&#10;// With TCPVirtualBytesSendQueue/RcvQueue, TCP passes up data to us&#10;// as soon as a segment arrives, so it can be echoed immediately.&#10;// With TCPMsgBasedSendQueue/RcvQueue, our local TCP reproduces the same&#10;// messages that the sender app passed down to its TCP -- so if the sender&#10;// app sent a single 100 MB message, it will be echoed only when all&#10;// 100 megabytes have arrived.&#10;//&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;"/>
  <tag type="simple-module" name="TCPGenericSrvApp" htmlfile="TCPGenericSrvApp-id220613.html" nedfile="Applications/TCPApp/TCPGenericSrvApp.ned" comment="//&#10;// Generic server application for modelling TCP-based request-reply style&#10;// protocols or applications.&#10;//&#10;// Requires message object preserving sendQueue/receiveQueue classes&#10;// to be used with TCP (that is, TCPMsgBasedSendQueue and TCPMsgBasedRcvQueue;&#10;// TCPVirtualBytesSendQueue/RcvQueue are not good).&#10;//&#10;// The module accepts any number of incoming \TCP connections, and expects&#10;// to receive messages of class GenericAppMsg on them. A message should&#10;// contain how large the reply should be (number of bytes). TCPGenericSrvApp&#10;// will just change the length of the received message accordingly, and send&#10;// back the same message object. The reply can be delayed by a constant time&#10;// (replyDelay parameter).&#10;//&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;// @see GenericAppMsg, TCPBasicClientApp, TelnetApp&#10;//&#10;"/>
  <tag type="simple-module" name="TCPSessionApp" htmlfile="TCPSessionApp-id220885.html" nedfile="Applications/TCPApp/TCPSessionApp.ned" comment="//&#10;// Single-connection TCP application: it opens a connection, sends&#10;// the given number of bytes, and closes. Sending may be one-off,&#10;// or may be controlled by a &quot;script&quot; which is a series of&#10;// (time, number of bytes) pairs. May act either as client or as server,&#10;// and works with TCPVirtualBytesSendQueue/RcvQueue as sendQueue/receiveQueue&#10;// setting for TCP.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;// &lt;b&gt;Opening the connection&lt;/b&gt;&#10;//&#10;// Regarding the type of opening the connection, the application may&#10;// be either a client or a server. When active=false, the application&#10;// will listen on the given local port, and wait for an incoming connection.&#10;// When active=true, the application will bind to given local address:port,&#10;// and connect to the connectAddress:connectPort. To use an ephemeral port&#10;// as local port, set the port parameter to -1.&#10;//&#10;// Even when in server mode (active=false), the application will only&#10;// serve one incoming connection. Further connect attempts will be&#10;// refused by TCP (it will send RST) for lack of LISTENing connections.&#10;//&#10;// The time of opening the connection is in the tOpen parameter.&#10;//&#10;// &lt;b&gt;Sending data&lt;/b&gt;&#10;//&#10;// Regardless of the type of OPEN, the application can be made to send&#10;// data. One way of specifying sending is via the tSend, sendBytes&#10;// parameters, the other way is sendScript. With the former, sendBytes&#10;// bytes will be sent at tSend. With sendScript, the format is&#10;// &quot;&lt;time&gt; &lt;numBytes&gt;;&lt;time&gt; &lt;numBytes&gt;;...&quot;&#10;//&#10;// &lt;b&gt;Closing the connection&lt;/b&gt;&#10;//&#10;// The application will issue a \TCP CLOSE at time tClose. If tClose=-1, no&#10;// CLOSE will be issued.&#10;//&#10;"/>
  <tag type="simple-module" name="TCPSinkApp" htmlfile="TCPSinkApp-id221723.html" nedfile="Applications/TCPApp/TCPSinkApp.ned" comment="//&#10;// Accepts any number of incoming TCP connections, and discards whatever&#10;// arrives on them.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;"/>
  <tag type="simple-module" name="TCPSpoof" htmlfile="TCPSpoof-id223974.html" nedfile="Applications/TCPApp/TCPSpoof.ned" comment="//&#10;// Sends fabricated TCP packets. This is a base implementation,&#10;// you'll probably have to customize it in C++ according to&#10;// what you want to send and when you want to send it.&#10;//&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;"/>
  <tag type="simple-module" name="TCPSrvHostApp" htmlfile="TCPSrvHostApp-id224178.html" nedfile="Applications/TCPApp/TCPSrvHostApp.ned" comment="//&#10;// This module hosts TCP-based server applications. It dynamically creates&#10;// and launches a new &quot;thread&quot; object for each incoming connection.&#10;//&#10;// Server threads should be subclassed from the TCPServerThreadBase&#10;// C++ class, registered in the C++ code using the Register_Class() macro,&#10;// and the class name should be specified in the serverThreadClass&#10;// parameter of TCPSrvHostApp. The thread object will receive events&#10;// via a callback interface (methods like established(), dataArrived(),&#10;// peerClosed(), timerExpired()), and can send packets via TCPSocket's send()&#10;// method.&#10;//&#10;// Example server thread class: TCPGenericSrvThread (in the C++ documentation only).&#10;//&#10;// IMPORTANT: Before you try to use this module, make sure you actually need it!&#10;// In most cases, TCPGenericSrvApp and GenericAppMsg will be completely&#10;// enough, and they are a lot easier to handle. You'll want to subclass your&#10;// client from TCPGenericCliAppBase then; check TelnetApp and TCPBasicClientApp&#10;// for examples.&#10;//&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;"/>
  <tag type="simple-module" name="TED" htmlfile="TED-id238461.html" nedfile="Network/TED/TED.ned" comment="//&#10;// Traffic Engineering Database. Stores network topology with detailed&#10;// link information, including total and reserved bandwidths.&#10;//&#10;// TED is filled in and kept up-to-date via link state routing protocols,&#10;// like LinkStateRouting or (in the future) OSPF-TE.&#10;//&#10;// \TED exposes several public methods for querying the current network state&#10;// and allows RSVP and individual applications to calculate feasible LSPs&#10;// meeting the chosen bandwidth criteria.&#10;//&#10;"/>
  <tag type="simple-module" name="TelnetApp" htmlfile="TelnetApp-id224257.html" nedfile="Applications/TCPApp/TelnetApp.ned" comment="//&#10;// Models Telnet sessions with a specific user behaviour.&#10;// The server app should be TCPGenericSrvApp.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;// NOTE: This module emulates a very specific user behaviour, and as such,&#10;// it should be viewed as an example rather than a generic Telnet model.&#10;// If you want to model realistic Telnet traffic, you are encouraged&#10;// to gather statistics from packet traces on a real network, and&#10;// write your model accordingly.&#10;//&#10;"/>
  <tag type="simple-module" name="ThruputMeter" htmlfile="ThruputMeter-id253880.html" nedfile="NetworkInterfaces/PPP/ThruputMeter.ned" comment="//&#10;// Thruput measurement utility module.&#10;//&#10;"/>
  <tag type="simple-module" name="TurtleMobility" htmlfile="TurtleMobility-id227222.html" nedfile="Mobility/TurtleMobility.ned" comment="//&#10;// A LOGO-style movement model, with the script coming from XML. It can be&#10;// useful for describing random as well as deterministic scenarios.&#10;//&#10;// First, a few examples.&#10;//&#10;// Node will move along a square's borders:&#10;//&#10;// &lt;pre&gt;&lt;nohtml&gt;&#10;//     &lt;movement&gt;&#10;//         &lt;set speed=&quot;10&quot; angle=&quot;180&quot;/&gt;&#10;//         &lt;repeat n=&quot;4&quot;&gt;&#10;//             &lt;forward d=&quot;50&quot;/&gt;&#10;//             &lt;turn angle=&quot;90&quot;/&gt;&#10;//         &lt;/repeat&gt;&#10;//     &lt;/movement&gt;&#10;// &lt;/nohtml&gt;&lt;/pre&gt;&#10;//&#10;// MassMobility (in which the node is assumed to have a mass, and cannot turn&#10;// abruptly):&#10;//&#10;// &lt;pre&gt;&lt;nohtml&gt;&#10;//     &lt;movement&gt;&#10;//         &lt;repeat&gt;&#10;//             &lt;set speed=&quot;uniform(10,20)&quot;/&gt;&#10;//             &lt;turn angle=&quot;uniform(-30,30)&quot;/&gt;&#10;//             &lt;forward t=&quot;uniform(0.1,1)&quot;/&gt;&#10;//         &lt;/repeat&gt;&#10;//     &lt;/movement&gt;&#10;// &lt;/nohtml&gt;&lt;/pre&gt;&#10;//&#10;// Random Waypoint:&#10;//&#10;// &lt;pre&gt;&lt;nohtml&gt;&#10;//     &lt;movement&gt;&#10;//         &lt;repeat&gt;&#10;//             &lt;set speed=&quot;uniform(20,60)&quot;/&gt;&#10;//             &lt;moveto x=&quot;uniform(0,$MAXX)&quot; y=&quot;uniform(0,$MAXY)&quot;/&gt;&#10;//         &lt;/repeat&gt;&#10;//     &lt;/movement&gt;&#10;// &lt;/nohtml&gt;&lt;/pre&gt;&#10;//&#10;// Commands (XML element names) are: repeat, set, forward, turn, wait,&#10;// moveto, and moveby.&#10;//&#10;// Accepted attributes:&#10;//    - repeat: n (optional)&#10;//    - set: x, y, speed, angle, borderPolicy (all optional)&#10;//    - forward: d, t (at last one of them must be present)&#10;//    - turn: angle (required)&#10;//    - wait: t (required)&#10;//    - moveto: x, y, t (all optional)&#10;//    - moveby: x, y, t (all optional)&#10;//&#10;// Attribute values can be literal numbers (e.g. x=&quot;100&quot;), or any&#10;// distribution accepted in omnetpp.ini (e.g. speed=&quot;uniform(10,20)&quot;).&#10;// A new value will be chosen each time the statement is executed.&#10;// The $MAXX and $MAXY strings will be substituted with the&#10;// playground width and height minus 1, respectively.&#10;//&#10;// t is time interval, calculated from the end of the previous movement.&#10;// x, y are absolute coordinates with &lt;set&gt; and &lt;moveto&gt;, and relative&#10;// with &lt;moveby&gt;. angle is clockwise in degrees, with 0 pointing west.&#10;// d is distance in meters (speed is m/s).&#10;//&#10;// borderPolicy controls what happens when a node reaches the edge of the&#10;// playground, and can take one of the values &quot;reflect&quot;, &quot;wrap&quot;,&#10;// &quot;placerandomly&quot;. In the first case, the node reflects off the wall;&#10;// with &quot;wrap&quot;, it'll come in on the other side (torus); and with&#10;// &quot;placerandomly&quot;, it will be placed at a random position on the&#10;// playground.&#10;//&#10;// In addition to the node position, the module maintains two interval variables,&#10;// 'speed' and 'angle', which can be adjusted by &lt;set&gt; and &lt;turn&gt;.&#10;// The &lt;forward&gt; statement, if only t or d is given, uses the speed variable.&#10;// If you specify d and t together, that determines speed as well,&#10;// so the speed variable will be ignored completely.&#10;//&#10;// Likewise, &lt;moveto&gt; and &lt;moveby&gt; will ignore the angle variable,&#10;// and will only use the speed variable if the t attribute is omitted.&#10;//&#10;// If the repeat count n is omitted for the &lt;repeat&gt; statement, that&#10;// means an infinite loop.&#10;//&#10;//&#10;//&#10;// You can find the DTD with the sources: TurtleMobility.dtd.&#10;//&#10;// @see ChannelControl&#10;// @author Andras Varga&#10;//&#10;"/>
  <tag type="simple-module" name="UDP" htmlfile="UDP-id272076.html" nedfile="Transport/UDP/UDP.ned" comment="//&#10;// UDP protocol implementation, for IPv4 and IPv6.&#10;//&#10;// The \UDP protocol header is represented by the class UDPPacket.&#10;//&#10;// &lt;b&gt;Communication with clients (applications)&lt;/b&gt;&#10;//&#10;// The module can (should) be connected to several applications.&#10;// For sending an \UDP packet, the application should attach an UDPControlInfo&#10;// object to the payload, and send it to UDP.&#10;// UDP will also attach an UDPControlInfo object to any payload&#10;// message in sends up to the application.&#10;//&#10;// For receiving \UDP packets, the connected applications should first&#10;// &quot;bind&quot; to the given \UDP port. This can be done by sending an&#10;// arbitrary message with message kind UDP_C_BIND and an UDPControlInfo&#10;// attached with srcPort filled in.&#10;//&#10;// If there is only one app which doesn't bind to any port, it will&#10;// receive all packets.&#10;//&#10;// &lt;b&gt;Communication with the \IP (IPv4/IPv6) layer&lt;/b&gt;&#10;//&#10;// The UDP model relies on sending and receiving IPControlInfo/IPv6ControlInfo&#10;// objects attached to UDPPacket objects as control info&#10;// (see cMessage::setControlInfo()).&#10;//&#10;// @see UDPPacket, UDPControlInfo, UDPCommandCode&#10;//&#10;"/>
  <tag type="simple-module" name="UDPApp" htmlfile="UDPApp-id224556.html" nedfile="Applications/UDPApp/UDPApp.ned" comment="//&#10;// Template for UDP applications.&#10;//&#10;// This is not an actual module type. It only shows which gates an UDP app &#10;// needs, to be able to be used in StandardHost etc.&#10;//&#10;"/>
  <tag type="simple-module" name="UDPBasicApp" htmlfile="UDPBasicApp-id224765.html" nedfile="Applications/UDPApp/UDPBasicApp.ned" comment="//&#10;// Sends \UDP packets to the given \IP address at the given interval.&#10;// Compatible with both IPv4 and IPv6.&#10;//&#10;// The interval can be a constant or a random value (e.g. exponential(1)).&#10;// If the dest_addresses parameter contains more than one address, one&#10;// of them is randomly chosen for each packet. An address may be given in the&#10;// dotted decimal notation, or with the module name. (The IPAddressResolver&#10;// class is used to resolve the address.) To disable the model, set&#10;// dest_addresses to &quot;&quot;.&#10;//&#10;// The peer can be UDPSink or another UDPBasicApp (it handles received packets&#10;// exactly like UDPSink).&#10;//&#10;//#FIXME change message length to BYTES&#10;//&#10;"/>
  <tag type="simple-module" name="UDPEchoApp" htmlfile="UDPEchoApp-id224850.html" nedfile="Applications/UDPApp/UDPEchoApp.ned" comment="//&#10;// Similar to UDPBasicApp, but it sends back the packet after reception.&#10;//&#10;"/>
  <tag type="simple-module" name="UDPSink" htmlfile="UDPSink-id225000.html" nedfile="Applications/UDPApp/UDPSink.ned" comment="//&#10;// Consumes and prints packets received from the UDP module.&#10;//&#10;"/>
  <tag type="simple-module" name="UDPVideoStreamCli" htmlfile="UDPVideoStreamCli-id224954.html" nedfile="Applications/UDPApp/UDPVideoStreamCli.ned" comment="//&#10;// Video streaming client.&#10;//&#10;// @see UDPVideoStreamSvr&#10;//&#10;"/>
  <tag type="simple-module" name="UDPVideoStreamSvr" htmlfile="UDPVideoStreamSvr-id225110.html" nedfile="Applications/UDPApp/UDPVideoStreamSvr.ned" comment="//&#10;// Video stream server. To be used with UDPVideoStreamCli.&#10;//&#10;// The server will wait for incoming &quot;video streaming requests&quot;.&#10;// When a request arrives, it draws a random video stream size&#10;// using the videoSize parameter, and starts streaming to the client.&#10;// During streaming, it will send \UDP packets of size packetLen at every&#10;// waitInterval, until videoSize is reached. The parameters packetLen&#10;// and waitInterval can be set to constant values to create CBR traffic,&#10;// or to random values (e.g. waitInterval=uniform(1e-6, 1.01e-6)) to&#10;// accomodate jitter.&#10;//&#10;// The server can serve several clients, and several streams per client.&#10;//&#10;// @see UDPVideoStreamCli&#10;//&#10;"/>
  <tag type="simple-module" name="WirelessMac" htmlfile="WirelessMac-id252850.html" nedfile="NetworkInterfaces/MFCore/WirelessMac.ned" comment="//&#10;// This is not an actual MAC implementation, just a prototype for wireless MAC's&#10;// that use a MF (Mobility Framework)-based physical layer.&#10;//&#10;// This component has been taken over from Mobility Framework 1.0a5.&#10;//&#10;// @author Daniel Willkomm, Andras Varga&#10;//&#10;"/>
  <tag type="struct" name="EroObj_t" htmlfile="EroObj_t-id236936.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Explicit Routing Object Structure&#10;//&#10;"/>
  <tag type="struct" name="ExternalTOSInfo" htmlfile="ExternalTOSInfo-id235037.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment=""/>
  <tag type="struct" name="FEC_TLV" htmlfile="FEC_TLV-id233442.html" nedfile="Network/LDP/LDPPacket.msg" comment=""/>
  <tag type="struct" name="FilterSpecObj_t" htmlfile="FilterSpecObj_t-id236850.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Sender Template Structure&#10;//&#10;"/>
  <tag type="struct" name="FlowDescriptor_t" htmlfile="FlowDescriptor_t-id236972.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Flow Descriptor Structure&#10;//&#10;"/>
  <tag type="struct" name="FlowSpecObj_t" htmlfile="FlowSpecObj_t-id236826.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Sender Tspec Structure&#10;//&#10;"/>
  <tag type="struct" name="Ieee80211CapabilityInformation" htmlfile="Ieee80211CapabilityInformation-id248133.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Capability Information field format. This field is not used&#10;// by the model (and is omitted from management frame formats too),&#10;// because its fields are related to features not supported by this model&#10;// (PCF, privacy, and beacons in ad-hoc mode). It is only provided here&#10;// for completeness.&#10;//&#10;"/>
  <tag type="struct" name="Ieee80211HandoverParameters" htmlfile="Ieee80211HandoverParameters-id247880.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Additional parameters for handover decisions&#10;// (Not part of standard, for experimental purposes)&#10;//&#10;"/>
  <tag type="struct" name="Ieee80211SupportedRatesElement" htmlfile="Ieee80211SupportedRatesElement-id248189.html" nedfile="NetworkInterfaces/Ieee80211/Mgmt/Ieee80211MgmtFrames.msg" comment="//&#10;// Structure to store supported rates&#10;//&#10;"/>
  <tag type="struct" name="LSARequest" htmlfile="LSARequest-id235339.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment=""/>
  <tag type="struct" name="LabelRequestObj_t" htmlfile="LabelRequestObj_t-id236875.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Label Request Object Structure&#10;//&#10;"/>
  <tag type="struct" name="OSPFDDOptions" htmlfile="OSPFDDOptions-id235193.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="// should be a byte long bitfield&#10;"/>
  <tag type="struct" name="OSPFOptions" htmlfile="OSPFOptions-id234399.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment="// should be a byte long bitfield&#10;"/>
  <tag type="struct" name="RsvpHopObj_t" htmlfile="RsvpHopObj_t-id236643.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: RSVP HOP Structure&#10;//&#10;"/>
  <tag type="struct" name="SenderDescriptor_t" htmlfile="SenderDescriptor_t-id236901.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Sender Descriptor Structure&#10;//&#10;"/>
  <tag type="struct" name="SenderTemplateObj_t" htmlfile="SenderTemplateObj_t-id236762.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Sender Template Structure&#10;//&#10;"/>
  <tag type="struct" name="SenderTspecObj_t" htmlfile="SenderTspecObj_t-id236798.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Sender Tspec Structure&#10;//&#10;"/>
  <tag type="struct" name="SessionObj_t" htmlfile="SessionObj_t-id236723.html" nedfile="Network/RSVP_TE/IntServ.msg" comment="//&#10;// Intserv/RSVP: Session Structure&#10;//&#10;"/>
  <tag type="struct" name="TCPPayloadMessage" htmlfile="TCPPayloadMessage-id271741.html" nedfile="Transport/TCP/TCPSegment.msg" comment=""/>
  <tag type="struct" name="TELinkStateInfo" htmlfile="TELinkStateInfo-id238678.html" nedfile="Network/TED/TED.msg" comment="//&#10;// Represents a link in the TED and in LinkStateMsg packets.&#10;//&#10;"/>
  <tag type="struct" name="TOSData" htmlfile="TOSData-id234762.html" nedfile="Network/OSPFv2/OSPFPacket.msg" comment=""/>
</neddoc-tags>
